{% extends "base.html" %}

{% block title %}血糖数据 - Nightscout 血糖监控{% endblock %}

{% block content %}
<div class="row">
    <!-- 控制面板 -->
    <div class="col-12 mb-4">
        <div class="card">
            <div class="card-header">
                <h5 class="card-title mb-0">
                    <i class="fas fa-tachometer-alt"></i> 控制面板
                </h5>
            </div>
            <div class="card-body">
                <div class="row align-items-center">
                    <div class="col-12 col-xl-7 mb-3 mb-xl-0">
                        <div class="btn-group flex-wrap" role="group" style="gap: 2px;">
                            <button type="button" class="btn btn-primary active btn-sm" style="padding: 0.25rem 0.5rem; font-size: 0.8rem;" onclick="loadData(1)">今日</button>
                            <button type="button" class="btn btn-outline-primary btn-sm" style="padding: 0.25rem 0.5rem; font-size: 0.8rem;" onclick="loadData(3)">3日</button>
                            <button type="button" class="btn btn-outline-primary btn-sm" style="padding: 0.25rem 0.5rem; font-size: 0.8rem;" onclick="loadData(7)">7日</button>
                            <button type="button" class="btn btn-outline-primary btn-sm" style="padding: 0.25rem 0.5rem; font-size: 0.8rem;" onclick="loadData(15)">15日</button>
                            <button type="button" class="btn btn-outline-primary btn-sm" style="padding: 0.25rem 0.5rem; font-size: 0.8rem;" onclick="loadData(30)">30日</button>
                            <button type="button" class="btn btn-outline-primary btn-sm" style="padding: 0.25rem 0.5rem; font-size: 0.8rem;" onclick="loadData(60)">60日</button>
                            <button type="button" class="btn btn-outline-primary btn-sm" style="padding: 0.25rem 0.5rem; font-size: 0.8rem;" onclick="loadData(90)">90日</button>
                            <button type="button" class="btn btn-outline-info btn-sm" style="padding: 0.25rem 0.5rem; font-size: 0.8rem;" data-bs-toggle="collapse" data-bs-target="#customDateCollapse">自定义</button>
                        </div>
                    </div>
                    <div class="col-12 col-xl-5">
                        <div class="d-grid gap-1 d-md-flex justify-content-md-end flex-wrap" style="gap: 2px;">
                            <button class="btn btn-primary btn-sm" style="padding: 0.25rem 0.5rem; font-size: 0.8rem;" onclick="generateReport()">
                                <i class="fas fa-file-alt"></i> <span class="d-none d-sm-inline">生成报表</span>
                            </button>
                            <button class="btn btn-success btn-sm" style="padding: 0.25rem 0.5rem; font-size: 0.8rem;" onclick="getAnalysis()">
                                <i class="fas fa-brain"></i> <span class="d-none d-sm-inline">AI分析</span>
                            </button>
                            <button class="btn btn-warning btn-sm" style="padding: 0.25rem 0.5rem; font-size: 0.8rem;" onclick="openAIConsult()">
                                <i class="fas fa-comments"></i> <span class="d-none d-sm-inline">AI咨询</span>
                            </button>
                            <button class="btn btn-info btn-sm" style="padding: 0.25rem 0.5rem; font-size: 0.8rem;" onclick="openMessageInbox()">
                                <i class="fas fa-envelope"></i> <span class="d-none d-sm-inline">消息记录</span>
                            </button>
                            <button class="btn btn-warning btn-sm" style="padding: 0.25rem 0.5rem; font-size: 0.8rem;" onclick="manualPrediction()">
                                <i class="fas fa-chart-line"></i> <span class="d-none d-sm-inline">重新预测</span>
                            </button>
                                                    </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 自定义日期选择 -->
    <div class="col-12 mb-4">
        <div class="collapse" id="customDateCollapse">
            <div class="card card-body">
                <div class="row align-items-end">
                    <div class="col-md-5 mb-2 mb-md-0">
                        <label for="startDate" class="form-label">开始日期</label>
                        <input type="date" id="startDate" class="form-control form-control-sm">
                    </div>
                    <div class="col-md-5 mb-2 mb-md-0">
                        <label for="endDate" class="form-label">结束日期</label>
                        <input type="date" id="endDate" class="form-control form-control-sm">
                    </div>
                    <div class="col-md-2">
                        <button class="btn btn-primary btn-sm w-100" onclick="loadCustomDateRange()">查询</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 统计卡片 -->
    <div class="col-12 mb-4">
        <div class="row" id="stats-cards">
            <div class="col-6 col-lg-3 mb-3">
                <div class="card text-center h-100">
                    <div class="card-body py-3">
                        <h6 class="card-title text-info mb-2"><i class="fas fa-clock"></i> 当前血糖</h6>
                        <h4 id="current-glucose-value" class="mb-1">--</h4>
                        <small id="current-glucose-unit" class="text-muted">mmol/L</small>
                        <div id="current-glucose-direction" class="mt-1">
                            <small class="text-muted">--</small>
                        </div>
                    </div>
                </div>
            </div>
            <div class="col-6 col-lg-3 mb-3">
                <div class="card text-center h-100">
                    <div class="card-body py-3">
                        <h6 class="card-title text-primary mb-2">平均血糖</h6>
                        <h4 id="avg-glucose" class="mb-1">--</h4>
                        <small class="text-muted">mmol/L</small>
                    </div>
                </div>
            </div>
            <div class="col-6 col-lg-3 mb-3">
                <div class="card text-center h-100">
                    <div class="card-body py-3">
                        <h6 class="card-title text-success mb-2">目标范围内</h6>
                        <h4 id="in-range" class="mb-1">--</h4>
                        <small class="text-muted">%</small>
                    </div>
                </div>
            </div>
            <div class="col-6 col-lg-3 mb-3">
                <div class="card text-center h-100">
                    <div class="card-body py-3">
                        <h6 class="card-title text-warning mb-2">最高血糖</h6>
                        <h4 id="max-glucose" class="mb-1">--</h4>
                        <small class="text-muted">mmol/L</small>
                    </div>
                </div>
            </div>
            <div class="col-6 col-lg-3 mb-3">
                <div class="card text-center h-100">
                    <div class="card-body py-3">
                        <h6 class="card-title text-danger mb-2">最低血糖</h6>
                        <h4 id="min-glucose" class="mb-1">--</h4>
                        <small class="text-muted">mmol/L</small>
                    </div>
                </div>
            </div>
            <div class="col-6 col-lg-3 mb-3">
                <div class="card text-center h-100">
                    <div class="card-body py-3">
                        <h6 class="card-title text-info mb-2">糖化血红蛋白</h6>
                        <h4 id="hba1c-value" class="mb-1">--</h4>
                        <small id="hba1c-unit" class="text-muted">%</small>
                        <div id="hba1c-status" class="mt-1">
                            <small class="badge bg-secondary">--</small>
                        </div>
                    </div>
                </div>
            </div>
            <div class="col-6 col-lg-3 mb-3">
                <div class="card text-center h-100">
                    <div class="card-body py-3">
                        <h6 class="card-title text-purple mb-2">血糖变异系数</h6>
                        <h4 id="cv-value" class="mb-1">--</h4>
                        <small class="text-muted">%</small>
                        <div id="cv-status" class="mt-1">
                            <small class="badge bg-secondary">--</small>
                        </div>
                    </div>
                </div>
            </div>
            <div class="col-6 col-lg-3 mb-3">
                <div class="card text-center h-100" id="prediction-card">
                    <div class="card-body py-3">
                        <h6 class="card-title text-info mb-2">
                            <i class="fas fa-chart-line"></i> 30分钟预测
                        </h6>
                        <p id="predicted-glucose" class="mb-2 text-primary">--</p>
                        <div id="prediction-confidence" class="mt-1">
                            <small class="badge bg-secondary">--</small>
                        </div>
                        <div id="risk-indicator" class="mt-1">
                            <small class="badge bg-success">低风险</small>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 警报通知 -->
    <div class="col-12 mb-4" id="alert-section" style="display: none;">
        <div class="alert alert-danger alert-dismissible fade show" role="alert">
            <div class="d-flex align-items-center">
                <i class="fas fa-exclamation-triangle me-2"></i>
                <div>
                    <h6 class="alert-heading mb-1" id="alert-title">低血糖警报</h6>
                    <p class="mb-1" id="alert-message">预测30分钟后可能发生低血糖</p>
                    <small id="alert-time" class="text-muted"></small>
                </div>
                <button type="button" class="btn-close ms-auto" onclick="dismissAlert()"></button>
            </div>
        </div>
    </div>

    <!-- 血糖图表 -->
    <div class="col-12 mb-4">
        <div class="card">
            <div class="card-header">
                <h5 class="card-title mb-0">
                    <i class="fas fa-chart-line"></i> 血糖趋势图
                </h5>
            </div>
            <div class="card-body">
                <div class="chart-container" style="position: relative; height: 300px;">
                    <canvas id="glucoseChart"></canvas>
                </div>
            </div>
        </div>
    </div>

    <!-- 血糖数据表格 -->
    <div class="col-12 col-xl-8 mb-4">
        <div class="card">
            <div class="card-header">
                <h5 class="card-title mb-0">
                    <i class="fas fa-table"></i> 血糖数据
                </h5>
            </div>
            <div class="card-body p-0">
                <div class="table-responsive">
                    <table class="table table-striped table-hover mb-0">
                        <thead class="sticky-header">
                            <tr>
                                <th class="d-none d-sm-table-cell">时间</th>
                                <th class="d-sm-none">时间/血糖</th>
                                <th class="d-none d-sm-table-cell">血糖值 (mmol/L)</th>
                                <th class="d-none d-md-table-cell">血糖值 (mg/dL)</th>
                                <th class="d-none d-sm-table-cell">趋势</th>
                            </tr>
                        </thead>
                        <tbody id="glucose-table-body">
                            <tr>
                                <td colspan="4" class="loading">
                                    <i class="fas fa-spinner fa-spin"></i> 加载中...
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <!-- 治疗数据表格 -->
    <div class="col-12 col-xl-4 mb-4">
        <div class="card">
            <div class="card-header">
                <h5 class="card-title mb-0">
                    <i class="fas fa-utensils"></i> 餐食记录
                </h5>
            </div>
            <div class="card-body p-0">
                <div class="table-responsive">
                    <table class="table table-striped table-hover mb-0">
                        <thead class="sticky-header">
                            <tr>
                                <th class="d-none d-sm-table-cell">时间</th>
                                <th class="d-sm-none">时间/营养</th>
                                <th class="d-none d-sm-table-cell">营养成分</th>
                                <th class="d-none d-md-table-cell">类型/备注</th>
                            </tr>
                        </thead>
                        <tbody id="treatment-table-body">
                            <tr>
                                <td colspan="3" class="loading">
                                    <i class="fas fa-spinner fa-spin"></i> 加载中...
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <!-- 运动数据表格 -->
    <div class="col-12 col-xl-4 mb-4">
        <div class="card">
            <div class="card-header">
                <h5 class="card-title mb-0">
                    <i class="fas fa-running"></i> 运动记录
                </h5>
            </div>
            <div class="card-body p-0">
                <div class="table-responsive">
                    <table class="table table-striped table-hover mb-0">
                        <thead class="sticky-header">
                            <tr>
                                <th class="d-none d-sm-table-cell">时间</th>
                                <th class="d-sm-none">时间/运动</th>
                                <th class="d-none d-sm-table-cell">运动类型</th>
                                <th class="d-none d-md-table-cell">时长/备注</th>
                            </tr>
                        </thead>
                        <tbody id="activity-table-body">
                            <tr>
                                <td colspan="3" class="loading">
                                    <i class="fas fa-spinner fa-spin"></i> 加载中...
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <!-- 指尖血糖数据表格 -->
    <div class="col-12 col-xl-4 mb-4">
        <div class="card">
            <div class="card-header">
                <h5 class="card-title mb-0">
                    <i class="fas fa-tint"></i> 指尖血糖记录
                </h5>
            </div>
            <div class="card-body p-0">
                <div class="table-responsive">
                    <table class="table table-striped table-hover mb-0">
                        <thead class="sticky-header">
                            <tr>
                                <th class="d-none d-sm-table-cell">时间</th>
                                <th class="d-sm-none">时间/血糖</th>
                                <th class="d-none d-sm-table-cell">血糖值</th>
                                <th class="d-none d-md-table-cell">同时间CGM血糖值</th>
                            </tr>
                        </thead>
                        <tbody id="meter-table-body">
                            <tr>
                                <td colspan="3" class="loading">
                                    <i class="fas fa-spinner fa-spin"></i> 加载中...
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- AI分析模态框 -->
<div class="modal fade" id="analysisModal" tabindex="-1">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">
                    <i class="fas fa-brain"></i> AI血糖分析报告
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <div id="analysis-content">
                    <div class="text-center">
                        <i class="fas fa-spinner fa-spin"></i> 分析中，请稍候...
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">关闭</button>
                <button type="button" class="btn btn-primary" onclick="copyAnalysis()">
                    <i class="fas fa-copy"></i> 复制分析
                </button>
            </div>
        </div>
    </div>
</div>

<!-- AI咨询模态框 -->
<div class="modal fade" id="consultModal" tabindex="-1">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">
                    <i class="fas fa-comments"></i> AI血糖咨询
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <div class="mb-3">
                    <label for="consultQuestion" class="form-label">请输入您的问题：</label>
                    <textarea class="form-control" id="consultQuestion" rows="3"
                              placeholder="例如：我今天的血糖波动大吗？应该注意什么？"></textarea>
                </div>
                <div class="mb-3">
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="includeGlucoseData" checked>
                        <label class="form-check-label" for="includeGlucoseData">
                            附带血糖信息作为上下文
                        </label>
                    </div>
                </div>
                <div id="consult-response" style="display: none;">
                    <hr>
                    <h6><i class="fas fa-robot"></i> AI回复：</h6>
                    <div id="consult-content" class="border rounded p-3 bg-light">
                        <!-- AI回复内容 -->
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">关闭</button>
                <button type="button" class="btn btn-primary" onclick="submitConsult()" id="consultSubmitBtn">
                    <i class="fas fa-paper-plane"></i> 提交咨询
                </button>
                <button type="button" class="btn btn-success" onclick="copyConsultResponse()" id="copyConsultBtn" style="display: none;">
                    <i class="fas fa-copy"></i> 复制回复
                </button>
            </div>
        </div>
    </div>
</div>

{% endblock %}

{% block extra_styles %}
<style>
    /* Markdown样式 */
    .ai-response, .ai-analysis {
        font-family: inherit;
        line-height: 1.6;
    }
    
    .ai-response h1, .ai-response h2, .ai-response h3, 
    .ai-response h4, .ai-response h5, .ai-response h6,
    .ai-analysis h1, .ai-analysis h2, .ai-analysis h3, 
    .ai-analysis h4, .ai-analysis h5, .ai-analysis h6 {
        margin-top: 1rem;
        margin-bottom: 0.5rem;
        font-weight: 600;
    }
    
    .ai-response h1, .ai-analysis h1 { font-size: 1.5rem; }
    .ai-response h2, .ai-analysis h2 { font-size: 1.3rem; }
    .ai-response h3, .ai-analysis h3 { font-size: 1.2rem; }
    .ai-response h4, .ai-analysis h4 { font-size: 1.1rem; }
    .ai-response h5, .ai-analysis h5 { font-size: 1rem; }
    .ai-response h6, .ai-analysis h6 { font-size: 0.9rem; }
    
    .ai-response ul, .ai-response ol,
    .ai-analysis ul, .ai-analysis ol {
        margin: 0.5rem 0;
        padding-left: 1.5rem;
    }
    
    .ai-response li, .ai-analysis li {
        margin: 0.25rem 0;
    }
    
    .ai-response pre, .ai-analysis pre {
        background-color: #f8f9fa;
        border: 1px solid #e9ecef;
        border-radius: 4px;
        padding: 1rem;
        overflow-x: auto;
        margin: 1rem 0;
    }
    
    .ai-response code, .ai-analysis code {
        background-color: #f8f9fa;
        border: 1px solid #e9ecef;
        border-radius: 3px;
        padding: 0.2rem 0.4rem;
        font-family: 'Courier New', monospace;
        font-size: 0.9rem;
    }
    
    .ai-response pre code, .ai-analysis pre code {
        background-color: transparent;
        border: none;
        padding: 0;
    }
    
    .ai-response blockquote, .ai-analysis blockquote {
        border-left: 4px solid #6c757d;
        padding-left: 1rem;
        margin: 1rem 0;
        color: #6c757d;
        font-style: italic;
    }
    
    .ai-response table, .ai-analysis table {
        width: 100%;
        margin: 1rem 0;
        border-collapse: collapse;
    }
    
    .ai-response th, .ai-response td,
    .ai-analysis th, .ai-analysis td {
        border: 1px solid #dee2e6;
        padding: 0.75rem;
        text-align: left;
    }
    
    .ai-response th, .ai-analysis th {
        background-color: #f8f9fa;
        font-weight: 600;
    }
    
    .ai-response a, .ai-analysis a {
        color: #0d6efd;
        text-decoration: none;
    }
    
    .ai-response a:hover, .ai-analysis a:hover {
        text-decoration: underline;
    }
    
    .ai-response img, .ai-analysis img {
        max-width: 100%;
        height: auto;
        border-radius: 4px;
        margin: 0.5rem 0;
    }
</style>
{% endblock %}

{% block extra_scripts %}
<script>
    let currentDays = 7;
    let glucoseChart = null;
    
    // 页面加载完成后初始化
    document.addEventListener('DOMContentLoaded', function() {
        // 设置自定义日期选择器的默认值
        const today = new Date().toISOString().split('T')[0];
        document.getElementById('endDate').value = today;
        const sevenDaysAgo = new Date();
        sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 6);
        document.getElementById('startDate').value = sevenDaysAgo.toISOString().split('T')[0];

        // 先同步数据，然后加载显示
        syncDataAndLoadToday();
        
        // 初始化表格选择功能
        setupTableSelection();
        
        // 更新未读消息数量
        updateUnreadCountIndicator();
    });

    // 同步数据并加载（页面加载时使用）
    function syncDataAndLoad() {
        // 静默同步，不显示成功提示
        fetch('/api/sync', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({days: 7})
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                // 只在控制台记录成功信息，不显示通知
                console.log(`同步成功！获取到 ${data.glucose_count} 条血糖数据和 ${data.treatment_count} 条治疗数据`);
                // 同步成功后加载数据
                loadData(7);
            } else {
                showNotification('同步失败: ' + data.error, 'warning');
                // 即使同步失败也尝试加载本地数据
                loadData(7);
            }
        })
        .catch(error => {
            console.error('同步失败:', error);
            showNotification('同步失败: ' + error.message, 'warning');
            // 同步失败也加载本地数据
            loadData(7);
        });
    }
    
    // 同步所有数据并加载今日数据（页面加载时使用）
    function syncDataAndLoadToday() {
        // 静默同步所有数据（使用较大的天数确保同步所有数据）
        fetch('/api/sync', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({days: 90}) // 同步90天的数据，基本覆盖所有历史数据
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                // 只在控制台记录成功信息，不显示通知
                console.log(`同步成功！获取到 ${data.glucose_count} 条血糖数据和 ${data.treatment_count} 条治疗数据`);
                // 同步成功后加载今日数据
                const url = `?days=1`;
                fetchAndLoadData(url);
            } else {
                showNotification('同步失败: ' + data.error, 'warning');
                // 即使同步失败也尝试加载今日数据
                const url = `?days=1`;
                fetchAndLoadData(url);
            }
        })
        .catch(error => {
            console.error('同步失败:', error);
            showNotification('同步失败: ' + error.message, 'warning');
            // 同步失败也加载今日数据
            const url = `?days=1`;
            fetchAndLoadData(url);
        });
    }
    
    // 更新按钮激活状态
    function updateActiveButton(targetButton) {
        document.querySelectorAll('.btn-group .btn, [data-bs-target="#customDateCollapse"]').forEach(btn => {
            btn.classList.remove('active', 'btn-primary');
            if (!btn.classList.contains('btn-outline-info')) {
                 btn.classList.add('btn-outline-primary');
            }
        });
        
        if (targetButton) {
            targetButton.classList.remove('btn-outline-primary', 'btn-outline-info');
            targetButton.classList.add('btn-primary', 'active');
        }
    }

    // 加载数据（按天数）
    function loadData(days) {
        currentDays = days;
        const url = `?days=${days}`;
        fetchAndLoadData(url);
        
        // 更新按钮状态 - 只选择带有onclick属性的按钮，排除"自定义"按钮
        const buttons = document.querySelectorAll('.btn-group .btn[onclick]');
        const btnDays = [1, 3, 7, 15, 30, 60, 90];
        const buttonIndex = btnDays.indexOf(days);
        if (buttonIndex !== -1 && buttonIndex < buttons.length) {
            updateActiveButton(buttons[buttonIndex]);
        }
    }

    // 加载数据（按自定义日期）
    function loadCustomDateRange() {
        const startDate = document.getElementById('startDate').value;
        const endDate = document.getElementById('endDate').value;

        if (!startDate || !endDate) {
            showNotification('请选择开始和结束日期', 'warning');
            return;
        }
        if (new Date(startDate) > new Date(endDate)) {
            showNotification('开始日期不能晚于结束日期', 'warning');
            return;
        }

        const url = `?start_date=${startDate}&end_date=${endDate}`;
        fetchAndLoadData(url);
        
        // 更新按钮状态
        const customButton = document.querySelector('[data-bs-target="#customDateCollapse"]');
        updateActiveButton(customButton);
    }

    // 核心数据获取和加载函数
    function fetchAndLoadData(urlParams) {
        // 加载血糖数据
        fetch(`/api/glucose-data${urlParams}`)
            .then(response => response.json())
            .then(glucoseData => {
                updateGlucoseTable(glucoseData);
                
                // 并行加载餐食和运动数据，然后更新图表
                Promise.all([
                    fetch(`/api/treatment-data${urlParams}`).then(response => response.json()),
                    fetch(`/api/activity-data${urlParams}`).then(response => response.json())
                ]).then(([treatmentData, activityData]) => {
                    updateGlucoseChart(glucoseData, treatmentData, activityData);
                }).catch(error => {
                    console.error('加载餐食或运动数据失败:', error);
                    // 即使餐食/运动数据加载失败，也只显示血糖数据
                    updateGlucoseChart(glucoseData, [], []);
                });
            })
            .catch(error => {
                console.error('加载血糖数据失败:', error);
                showNotification('加载血糖数据失败', 'danger');
            });

        // 加载统计数据
        fetch(`/api/statistics${urlParams}`)
            .then(response => response.json())
            .then(data => {
                updateStats(data);
            })
            .catch(error => {
                console.error('加载统计数据失败:', error);
                updateStats({});
            });
        
        // 加载治疗数据
        fetch(`/api/treatment-data${urlParams}`)
            .then(response => response.json())
            .then(data => {
                updateTreatmentTable(data);
            })
            .catch(error => {
                console.error('加载治疗数据失败:', error);
                showNotification('加载治疗数据失败', 'danger');
            });

        // 加载运动数据
        fetch(`/api/activity-data${urlParams}`)
            .then(response => response.json())
            .then(data => {
                updateActivityTable(data);
            })
            .catch(error => {
                console.error('加载运动数据失败:', error);
                showNotification('加载运动数据失败', 'danger');
            });

        // 加载指尖血糖数据
        fetch(`/api/meter-data${urlParams}`)
            .then(response => response.json())
            .then(data => {
                updateMeterTable(data);
            })
            .catch(error => {
                console.error('加载指尖血糖数据失败:', error);
                showNotification('加载指尖血糖数据失败', 'danger');
            });

        // 加载当前血糖数据
        fetch(`/api/current-glucose`)
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    console.error('加载当前血糖数据失败:', data.error);
                    updateCurrentGlucose({}); // 清空卡片
                } else {
                    updateCurrentGlucose(data);
                }
            })
            .catch(error => {
                console.error('加载当前血糖数据失败:', error);
                updateCurrentGlucose({}); // 清空卡片
            });
    }
    
    // PC桌面端表格性能优化函数
    async function renderTableWithPerformance(tbodyId, data, rowRenderer) {
        const tbody = document.getElementById(tbodyId);
        
        if (!tbody) {
            console.error('表格元素未找到:', tbodyId);
            return;
        }
        
        if (data.length === 0) {
            tbody.innerHTML = '<tr><td colspan="10" class="text-center text-muted">暂无数据</td></tr>';
            return;
        }
        
        // 显示加载指示器（大数据集）
        if (data.length > 200) {
            showTableLoadingIndicator(tbodyId, true);
        }
        
        // 使用 DocumentFragment 和分块处理优化性能
        const chunkSize = 100;
        const yieldInterval = 200; // 每200条记录让出UI线程
        
        try {
            // 清空表格并开始处理
            tbody.innerHTML = '';
            
            for (let i = 0; i < data.length; i += chunkSize) {
                const chunk = data.slice(i, i + chunkSize);
                const fragment = document.createDocumentFragment();
                
                // 处理当前块
                chunk.forEach((item, index) => {
                    const row = rowRenderer(item, i + index);
                    if (row) {
                        fragment.appendChild(row);
                    }
                });
                
                // 批量添加到DOM
                tbody.appendChild(fragment);
                
                // 定期让出UI线程以避免阻塞
                if ((i + chunkSize) % yieldInterval === 0) {
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }
            
            // 处理完成，隐藏加载指示器
            showTableLoadingIndicator(tbodyId, false);
            // 添加GPU加速类
            tbody.classList.add('gpu-accelerated');
            
        } catch (error) {
            console.error('表格渲染失败:', error);
            showTableLoadingIndicator(tbodyId, false);
        }
    }
    
    // 创建表格行元素
    function createTableRowElement(item, type) {
        const row = document.createElement('tr');
        row.className = 'table-row-enhanced';
        
        if (type === 'glucose') {
            // 血糖表格行
            const glucoseColor = getGlucoseColor(item.value_mmol);
            const directionArrow = formatDirection(item.direction);
            
            // 移动端合并显示
            const mobileContent = `
                <div class="d-flex justify-content-between align-items-center">
                    <div>
                        <div class="fw-bold">${item.time.split(' ')[1]}</div>
                        <div class="small text-muted">${item.time.split(' ')[0]}</div>
                    </div>
                    <div class="text-end">
                        <div class="fw-bold ${glucoseColor}">${item.value_mmol}</div>
                        <div class="small">${directionArrow}</div>
                    </div>
                </div>
            `;
            
            row.innerHTML = `
                <td class="d-none d-md-table-cell">${item.time.split(' ')[1]}</td>
                <td class="d-none d-md-table-cell">${item.time.split(' ')[0]}</td>
                <td class="text-center fw-bold ${glucoseColor}">${item.value_mmol}</td>
                <td class="text-center">${directionArrow}</td>
                <td class="d-table-cell d-md-none">${mobileContent}</td>
            `;
        } else if (type === 'treatment') {
            // 治疗表格行
            const durationDisplay = item.duration > 0 ? `${item.duration}分钟` : '-';
            
            const typeAndNotes = [];
            if (item.eventType) typeAndNotes.push(item.eventType);
            if (item.notes) typeAndNotes.push(item.notes);
            const typeAndNotesDisplay = typeAndNotes.length > 0 ? typeAndNotes.join(' - ') : '-';
            
            row.innerHTML = `
                <td>${item.time}</td>
                <td>${durationDisplay}</td>
                <td>${typeAndNotesDisplay}</td>
            `;
        } else if (type === 'prediction') {
            // 预测表格行
            const glucoseColor = getGlucoseColor(item.value_mmol);
            const cgmGlucoseColor = item.cgm_value_mmol ? getGlucoseColor(item.cgm_value_mmol) : 'text-muted';
            const cgmValueDisplay = item.cgm_value_mmol ? formatGlucoseValue(item.cgm_value_mmol) : 'N/A';
            
            row.innerHTML = `
                <td>${item.time}</td>
                <td class="text-center fw-bold ${glucoseColor}">${item.value_mmol}</td>
                <td class="text-center">${cgmValueDisplay}</td>
                <td class="text-center">${item.diff_mmol ? item.diff_mmol.toFixed(2) : 'N/A'}</td>
                <td class="text-center">${item.diff_percent ? item.diff_percent.toFixed(1) + '%' : 'N/A'}</td>
            `;
        }
        
        return row;
    }
    
    // 显示表格加载指示器
    function showTableLoadingIndicator(tbodyId, show) {
        const tbody = document.getElementById(tbodyId);
        const table = tbody.closest('table');
        
        if (show) {
            // 创建加载指示器
            const loadingRow = document.createElement('tr');
            loadingRow.id = `${tbodyId}-loading`;
            loadingRow.className = 'table-loading';
            loadingRow.innerHTML = `
                <td colspan="10" class="text-center py-4">
                    <div class="d-flex justify-content-center align-items-center">
                        <div class="spinner-border spinner-border-sm text-primary me-2" role="status">
                            <span class="visually-hidden">加载中...</span>
                        </div>
                        <span class="text-muted">正在加载数据...</span>
                    </div>
                </td>
            `;
            tbody.appendChild(loadingRow);
        } else {
            // 移除加载指示器
            const loadingRow = document.getElementById(`${tbodyId}-loading`);
            if (loadingRow) {
                loadingRow.remove();
            }
        }
    }
    
    // 更新血糖表格（优化版本）
    function updateGlucoseTable(data) {
        // 使用优化渲染函数
        renderTableWithPerformance('glucose-table-body', data, (item, index) => {
            return createTableRowElement(item, 'glucose');
        });
    }

    // 获取血糖值颜色
    function getGlucoseColor(value) {
        if (value < 3.9) return 'text-danger';
        if (value > 10.0) return 'text-warning';
        return 'text-success';
    }
    
    // 更新治疗表格（优化版本）
    function updateTreatmentTable(data) {
        // 过滤有营养成分的数据（碳水、蛋白质或脂肪任一大于0）
        const filteredData = data.filter(item =>
            (item.carbs && item.carbs > 0) ||
            (item.protein && item.protein > 0) ||
            (item.fat && item.fat > 0) ||
            item.event_type === 'Carb Correction' ||
            item.event_type === 'Meal Bolus'
        );

        // 使用优化渲染函数
        renderTableWithPerformance('treatment-table-body', filteredData, (item, index) => {
            const row = document.createElement('tr');
            row.className = 'table-row-enhanced';
            
            // 构建营养成分显示
            const nutritionParts = [];
            if (item.carbs && item.carbs > 0) {
                nutritionParts.push(`<span class="badge bg-primary me-1">${item.carbs}g碳水</span>`);
            }
            if (item.protein && item.protein > 0) {
                nutritionParts.push(`<span class="badge bg-success me-1">${item.protein}g蛋白质</span>`);
            }
            if (item.fat && item.fat > 0) {
                nutritionParts.push(`<span class="badge bg-warning me-1">${item.fat}g脂肪</span>`);
            }

            // 如果没有营养成分但是相关事件类型，显示事件类型
            const nutritionDisplay = nutritionParts.length > 0
                ? nutritionParts.join('')
                : `<span class="text-muted">${item.event_type || '无营养数据'}</span>`;

            // 构建类型/备注显示
            const typeAndNotes = [];
            if (item.event_type && item.event_type !== 'Meal Bolus') {
                typeAndNotes.push(item.event_type);
            }
            if (item.notes) {
                typeAndNotes.push(item.notes);
            }
            const typeDisplay = typeAndNotes.length > 0 ? typeAndNotes.join(' - ') : '-';

            // 移动端合并显示
            const mobileContent = `
                <div class="d-flex justify-content-between align-items-start">
                    <div>
                        <div class="fw-bold">${item.time.split(' ')[1]}</div>
                        <small class="text-muted">${item.time.split(' ')[0]}</small>
                    </div>
                    <div class="text-end">
                        <div class="mb-1">${nutritionDisplay}</div>
                        <small class="text-muted">${typeDisplay}</small>
                    </div>
                </div>
            `;

            row.innerHTML = `
                <td class="d-none d-sm-table-cell">${item.time}</td>
                <td class="d-sm-none">${mobileContent}</td>
                <td class="d-none d-sm-table-cell">${nutritionDisplay}</td>
                <td class="d-none d-md-table-cell">${typeDisplay}</td>
            `;
            
            return row;
        });
    }

    // 更新运动表格（优化版本）
    function updateActivityTable(data) {
        // 使用优化渲染函数
        renderTableWithPerformance('activity-table-body', data, (item, index) => {
            const row = document.createElement('tr');
            row.className = 'table-row-enhanced';
            
            // 构建时长显示
            const durationDisplay = item.duration > 0 ? `${item.duration}分钟` : '-';
            
            // 构建类型/备注显示
            const typeAndNotes = [];
            if (item.event_type) {
                typeAndNotes.push(item.event_type);
            }
            if (item.notes) {
                typeAndNotes.push(item.notes);
            }
            const typeDisplay = typeAndNotes.length > 0 ? typeAndNotes.join(' - ') : '-';

            // 移动端合并显示
            const mobileContent = `
                <div class="d-flex justify-content-between align-items-start">
                    <div>
                        <div class="fw-bold">${item.time.split(' ')[1]}</div>
                        <small class="text-muted">${item.time.split(' ')[0]}</small>
                    </div>
                    <div class="text-end">
                        <div class="mb-1">${item.event_type || '运动'}</div>
                        <small class="text-muted">${durationDisplay} ${typeDisplay !== '-' ? typeDisplay : ''}</small>
                    </div>
                </div>
            `;

            row.innerHTML = `
                <td class="d-none d-sm-table-cell">${item.time}</td>
                <td class="d-sm-none">${mobileContent}</td>
                <td class="d-none d-sm-table-cell">${item.event_type || '运动'}</td>
                <td class="d-none d-md-table-cell">${durationDisplay} ${typeDisplay !== '-' ? `<br><small class="text-muted">${typeDisplay}</small>` : ''}</td>
            `;
            
            return row;
        });
    }

    // 更新指尖血糖表格（优化版本）
    function updateMeterTable(data) {
        // 使用优化渲染函数
        renderTableWithPerformance('meter-table-body', data, (item, index) => {
            const row = document.createElement('tr');
            row.className = 'table-row-enhanced';
            
            // 获取血糖值颜色
            const glucoseColor = getGlucoseColor(item.value_mmol);
            const cgmGlucoseColor = item.cgm_value_mmol ? getGlucoseColor(item.cgm_value_mmol) : 'text-muted';
            const cgmValueDisplay = item.cgm_value_mmol ? formatGlucoseValue(item.cgm_value_mmol) : 'N/A';

            // 移动端合并显示
            const mobileContent = `
                <div class="d-flex justify-content-between align-items-start">
                    <div>
                        <div class="fw-bold">${item.time.split(' ')[1]}</div>
                        <small class="text-muted">${item.time.split(' ')[0]}</small>
                    </div>
                    <div class="text-end">
                        <div class="fw-bold ${glucoseColor}">指尖: ${formatGlucoseValue(item.value_mmol)} mmol/L</div>
                        <small class="${cgmGlucoseColor}">CGM: ${cgmValueDisplay} mmol/L</small>
                    </div>
                </div>
            `;

            row.innerHTML = `
                <td class="d-none d-sm-table-cell">${item.time}</td>
                <td class="d-sm-none">${mobileContent}</td>
                <td class="d-none d-sm-table-cell ${glucoseColor}">${formatGlucoseValue(item.value_mmol)}</td>
                <td class="d-none d-md-table-cell ${cgmGlucoseColor}">${cgmValueDisplay}</td>
            `;
            
            return row;
        });
    }
    
    // 更新统计信息
    function updateStats(data) {
        // 基础统计数据
        document.getElementById('avg-glucose').textContent = data.avg_glucose || '--';
        document.getElementById('in-range').textContent = data.in_range_percentage || '--';
        document.getElementById('max-glucose').textContent = data.max_glucose || '--';
        document.getElementById('min-glucose').textContent = data.min_glucose || '--';

        // 糖化血红蛋白
        if (data.hba1c_data && data.hba1c_data.hba1c_adag_percent) {
            const hba1c = data.hba1c_data.hba1c_adag_percent;
            const hba1cMmol = data.hba1c_data.hba1c_adag_mmol;

            document.getElementById('hba1c-value').textContent = hba1c;
            document.getElementById('hba1c-unit').textContent = `% (${hba1cMmol} mmol/mol)`;

            // 设置状态标签和颜色
            const statusElement = document.getElementById('hba1c-status');
            let statusText = '';
            let statusClass = '';

            if (hba1c < 5.7) {
                statusText = '正常范围';
                statusClass = 'bg-success';
            } else if (hba1c < 6.5) {
                statusText = '糖尿病前期';
                statusClass = 'bg-warning';
            } else if (hba1c < 7.0) {
                statusText = '控制良好';
                statusClass = 'bg-info';
            } else if (hba1c < 8.0) {
                statusText = '控制一般';
                statusClass = 'bg-warning';
            } else {
                statusText = '控制较差';
                statusClass = 'bg-danger';
            }

            statusElement.innerHTML = `<small class="badge ${statusClass}">${statusText}</small>`;
        } else {
            document.getElementById('hba1c-value').textContent = '--';
            document.getElementById('hba1c-unit').textContent = '%';
            document.getElementById('hba1c-status').innerHTML = '<small class="badge bg-secondary">--</small>';
        }

        // 血糖变异系数
        if (data.cv_data && data.cv_data.cv_percent) {
            const cv = data.cv_data.cv_percent;

            document.getElementById('cv-value').textContent = cv;

            // 设置状态标签和颜色
            const statusElement = document.getElementById('cv-status');
            let statusText = '';
            let statusClass = '';

            if (cv <= 36) {
                statusText = '波动良好';
                statusClass = 'bg-success';
            } else if (cv <= 50) {
                statusText = '波动一般';
                statusClass = 'bg-warning';
            } else {
                statusText = '波动较大';
                statusClass = 'bg-danger';
            }

            statusElement.innerHTML = `<small class="badge ${statusClass}">${statusText}</small>`;
        } else {
            document.getElementById('cv-value').textContent = '--';
            document.getElementById('cv-status').innerHTML = '<small class="badge bg-secondary">--</small>';
        }
    }

    // 更新当前血糖卡片
    function updateCurrentGlucose(data) {
        const valueEl = document.getElementById('current-glucose-value');
        const unitEl = document.getElementById('current-glucose-unit');
        const directionEl = document.getElementById('current-glucose-direction');

        if (data && data.value_mmol) {
            valueEl.textContent = data.value_mmol;
            valueEl.className = `mb-1 ${getGlucoseColor(data.value_mmol)}`;
            unitEl.textContent = 'mmol/L';
            directionEl.innerHTML = `<small class="text-muted">${formatDirection(data.direction)} (${data.time.split(' ')[1]})</small>`;
        } else {
            valueEl.textContent = '--';
            valueEl.className = 'mb-1';
            unitEl.textContent = 'mmol/L';
            directionEl.innerHTML = '<small class="text-muted">--</small>';
        }
    }
    
    // 表格行选择功能
    let tableSelectionInitialized = false;
    
    // 滚动配置管理
    const SCROLL_CONFIG = {
        threshold: 8,
        timeThreshold: 300,
        minVelocity: 0.5,
        minDebounceDelay: 100,
        maxDebounceDelay: 300
    };
    
    // 性能监控
    const performanceMonitor = {
        startTime: 0,
        start() {
            this.startTime = performance.now();
        },
        end(label) {
            const duration = performance.now() - this.startTime;
            if (duration > 50) { // 超过50ms记录
                console.warn(`${label} 耗时: ${duration.toFixed(2)}ms`);
            }
        }
    };
    
    function setupTableSelection() {
        // 避免重复初始化
        if (tableSelectionInitialized) {
            console.log('表格选择功能已经初始化，跳过重复绑定');
            return;
        }
        
        tableSelectionInitialized = true;
        
        // 为所有表格行添加点击事件
        const tableBodies = ['glucose-table-body', 'treatment-table-body', 'activity-table-body', 'meter-table-body'];
        
        // 创建滚动检测变量
        const scrollDetection = {
            isScrolling: false,
            scrollTimeout: null,
            touchStartX: 0,
            touchStartY: 0,
            touchStartTime: 0,
            scrollThreshold: SCROLL_CONFIG.threshold,  // 使用配置
            timeThreshold: SCROLL_CONFIG.timeThreshold,  // 使用配置
            lastTouchTime: 0,
            scrollVelocity: 0,
            lastScrollPosition: { x: 0, y: 0 }
        };
        
        tableBodies.forEach(bodyId => {
            const tbody = document.getElementById(bodyId);
            if (!tbody) return;
            
            // 获取表格容器
            const tableContainer = tbody.closest('.table-responsive');
            if (!tableContainer) return;
            
            // 清理现有的触摸事件监听器
            const clonedTbody = tbody.cloneNode(true);
            tbody.parentNode.replaceChild(clonedTbody, tbody);
            
            // 重新获取tbody引用
            const newTbody = document.getElementById(bodyId);
            
            // 添加点击事件
            newTbody.addEventListener('click', function(e) {
                // 如果正在滚动，不处理点击
                if (scrollDetection.isScrolling) return;
                
                const row = e.target.closest('tr');
                if (!row || row.classList.contains('loading')) return;
                
                // 移除同一表格中其他行的选中状态
                newTbody.querySelectorAll('tr.selected').forEach(selectedRow => {
                    if (selectedRow !== row) {
                        selectedRow.classList.remove('selected');
                    }
                });
                
                // 切换当前行的选中状态
                row.classList.toggle('selected');
                
                // 获取行数据并显示详情
                if (row.classList.contains('selected')) {
                    showTableRowDetails(row, bodyId);
                }
            });
            
            // 添加触摸开始事件
            newTbody.addEventListener('touchstart', function(e) {
                performanceMonitor.start('touchstart处理');
                
                try {
                    // 兼容性检查：确保touches数组存在
                    if (!e.touches || e.touches.length === 0) return;
                    
                    const touch = e.touches[0];
                    scrollDetection.touchStartX = touch.clientX;
                    scrollDetection.touchStartY = touch.clientY;
                    scrollDetection.touchStartTime = Date.now();
                    scrollDetection.lastTouchTime = Date.now();
                    scrollDetection.isScrolling = false;
                    scrollDetection.lastScrollPosition = { x: touch.clientX, y: touch.clientY };
                    scrollDetection.scrollVelocity = 0;
                } catch (error) {
                    console.error('触摸开始事件处理错误:', error);
                    // 优雅降级
                    scrollDetection.isScrolling = false;
                } finally {
                    performanceMonitor.end('touchstart处理');
                }
                
                // 不阻止默认行为，允许滚动
            }, { passive: true });
            
            // 添加触摸移动事件（滚动检测）
            newTbody.addEventListener('touchmove', function(e) {
                performanceMonitor.start('touchmove处理');
                
                try {
                    // 兼容性检查：确保touches数组存在
                    if (!e.touches || e.touches.length === 0) return;
                    
                    const touch = e.touches[0];
                    const deltaX = Math.abs(touch.clientX - scrollDetection.touchStartX);
                    const deltaY = Math.abs(touch.clientY - scrollDetection.touchStartY);
                    const currentTime = Date.now();
                    const timeDiff = currentTime - scrollDetection.lastTouchTime;
                    
                    // 计算滚动速度
                    if (timeDiff > 0) {
                        const velocityX = Math.abs(touch.clientX - scrollDetection.lastScrollPosition.x) / timeDiff;
                        const velocityY = Math.abs(touch.clientY - scrollDetection.lastScrollPosition.y) / timeDiff;
                        scrollDetection.scrollVelocity = Math.max(velocityX, velocityY);
                    }
                    
                    // 更新最后触摸位置和时间
                    scrollDetection.lastScrollPosition = { x: touch.clientX, y: touch.clientY };
                    scrollDetection.lastTouchTime = currentTime;
                    
                    // 检测是否是滚动操作 - 使用配置的智能判断
                    const isScrollGesture = (deltaX > scrollDetection.scrollThreshold || deltaY > scrollDetection.scrollThreshold) ||
                                         (scrollDetection.scrollVelocity > SCROLL_CONFIG.minVelocity);
                    
                    if (isScrollGesture) {
                        scrollDetection.isScrolling = true;
                        
                        // 添加滚动样式
                        tableContainer.classList.add('scrolling');
                        
                        // 清除之前的超时
                        if (scrollDetection.scrollTimeout) {
                            clearTimeout(scrollDetection.scrollTimeout);
                        }
                        
                        // 设置滚动结束检测 - 根据速度动态调整延迟
                        const debounceDelay = Math.min(
                            SCROLL_CONFIG.maxDebounceDelay, 
                            Math.max(SCROLL_CONFIG.minDebounceDelay, 200 / (scrollDetection.scrollVelocity + 0.1))
                        );
                        scrollDetection.scrollTimeout = setTimeout(() => {
                            scrollDetection.isScrolling = false;
                            tableContainer.classList.remove('scrolling');
                            scrollDetection.scrollVelocity = 0;
                        }, debounceDelay);
                    }
                } catch (error) {
                    console.error('触摸移动事件处理错误:', error);
                    // 优雅降级
                    scrollDetection.isScrolling = false;
                    if (scrollDetection.scrollTimeout) {
                        clearTimeout(scrollDetection.scrollTimeout);
                    }
                } finally {
                    performanceMonitor.end('touchmove处理');
                }
                
                // 不阻止默认行为，允许滚动
            }, { passive: true });
            
            // 添加触摸结束事件
            newTbody.addEventListener('touchend', function(e) {
                performanceMonitor.start('touchend处理');
                
                try {
                    const touchDuration = Date.now() - scrollDetection.touchStartTime;
                    
                    // 如果是快速点击且不是滚动，处理点击事件
                    if (!scrollDetection.isScrolling && touchDuration < scrollDetection.timeThreshold) {
                        // 兼容性检查：确保changedTouches数组存在
                        if (e.changedTouches && e.changedTouches.length > 0) {
                            const touch = e.changedTouches[0];
                            const targetElement = document.elementFromPoint(touch.clientX, touch.clientY);
                            const row = targetElement?.closest('tr');
                            
                            if (row && !row.classList.contains('loading')) {
                                // 模拟点击事件
                                const clickEvent = new MouseEvent('click', {
                                    bubbles: true,
                                    cancelable: true,
                                    view: window,
                                    clientX: touch.clientX,
                                    clientY: touch.clientY
                                });
                                row.dispatchEvent(clickEvent);
                            }
                        }
                    }
                } catch (error) {
                    console.error('触摸结束事件处理错误:', error);
                } finally {
                    performanceMonitor.end('touchend处理');
                }
                
                // 清理状态
                scrollDetection.isScrolling = false;
                scrollDetection.scrollVelocity = 0;
                if (scrollDetection.scrollTimeout) {
                    clearTimeout(scrollDetection.scrollTimeout);
                }
                tableContainer.classList.remove('scrolling');
            }, { passive: true });
            
            // 添加触摸取消事件处理
            newTbody.addEventListener('touchcancel', function(e) {
                performanceMonitor.start('touchcancel处理');
                
                try {
                    // 清理所有状态
                    scrollDetection.isScrolling = false;
                    scrollDetection.scrollVelocity = 0;
                    if (scrollDetection.scrollTimeout) {
                        clearTimeout(scrollDetection.scrollTimeout);
                    }
                    tableContainer.classList.remove('scrolling');
                } catch (error) {
                    console.error('触摸取消事件处理错误:', error);
                } finally {
                    performanceMonitor.end('touchcancel处理');
                }
            }, { passive: true });
        });
        
        console.log('表格选择功能初始化完成');
    }
    
    // 清理表格选择功能（用于重新初始化）
    function cleanupTableSelection() {
        const tableBodies = ['glucose-table-body', 'treatment-table-body', 'activity-table-body', 'meter-table-body'];
        
        tableBodies.forEach(bodyId => {
            const tbody = document.getElementById(bodyId);
            if (!tbody) return;
            
            // 获取表格容器
            const tableContainer = tbody.closest('.table-responsive');
            if (tableContainer) {
                tableContainer.classList.remove('scrolling');
            }
        });
        
        tableSelectionInitialized = false;
        console.log('表格选择功能已清理');
    }
    
    // 显示表格行详情
    function showTableRowDetails(row, tableType) {
        const cells = row.querySelectorAll('td');
        if (cells.length === 0) return;
        
        let details = '';
        let title = '';
        
        switch(tableType) {
            case 'glucose-table-body':
                title = '血糖数据详情';
                // 从移动端视图或桌面端视图提取数据
                const mobileCell = row.querySelector('.d-sm-none');
                if (mobileCell) {
                    // 移动端格式
                    const mobileContent = mobileCell.innerHTML;
                    details = mobileContent;
                } else {
                    // 桌面端格式
                    const time = cells[0]?.textContent || '';
                    const glucose = cells[1]?.textContent || '';
                    const mgdl = cells[2]?.textContent || '';
                    const direction = cells[3]?.textContent || '';
                    details = `
                        <div class="row">
                            <div class="col-6"><strong>时间:</strong> ${time}</div>
                            <div class="col-6"><strong>血糖:</strong> ${glucose}</div>
                            <div class="col-6"><strong>mg/dL:</strong> ${mgdl}</div>
                            <div class="col-6"><strong>趋势:</strong> ${direction}</div>
                        </div>
                    `;
                }
                break;
                
            case 'treatment-table-body':
                title = '餐食记录详情';
                const treatmentMobile = row.querySelector('.d-sm-none');
                if (treatmentMobile) {
                    details = treatmentMobile.innerHTML;
                } else {
                    const time = cells[0]?.textContent || '';
                    const nutrition = cells[1]?.textContent || '';
                    const type = cells[2]?.textContent || '';
                    details = `
                        <div class="row">
                            <div class="col-6"><strong>时间:</strong> ${time}</div>
                            <div class="col-6"><strong>营养:</strong> ${nutrition}</div>
                            <div class="col-12"><strong>类型:</strong> ${type}</div>
                        </div>
                    `;
                }
                break;
                
            case 'activity-table-body':
                title = '运动记录详情';
                const activityMobile = row.querySelector('.d-sm-none');
                if (activityMobile) {
                    details = activityMobile.innerHTML;
                } else {
                    const time = cells[0]?.textContent || '';
                    const activityType = cells[1]?.textContent || '';
                    const duration = cells[2]?.textContent || '';
                    details = `
                        <div class="row">
                            <div class="col-6"><strong>时间:</strong> ${time}</div>
                            <div class="col-6"><strong>类型:</strong> ${activityType}</div>
                            <div class="col-12"><strong>时长:</strong> ${duration}</div>
                        </div>
                    `;
                }
                break;
                
            case 'meter-table-body':
                title = '指尖血糖详情';
                const meterMobile = row.querySelector('.d-sm-none');
                if (meterMobile) {
                    details = meterMobile.innerHTML;
                } else {
                    const time = cells[0]?.textContent || '';
                    const glucose = cells[1]?.textContent || '';
                    const cgmGlucose = cells[2]?.textContent || '';
                    details = `
                        <div class="row">
                            <div class="col-6"><strong>时间:</strong> ${time}</div>
                            <div class="col-6"><strong>血糖:</strong> ${glucose}</div>
                            <div class="col-12"><strong>CGM血糖:</strong> ${cgmGlucose}</div>
                        </div>
                    `;
                }
                break;
        }
        
        // 显示详情模态框
        showTableDetailModal(title, details);
    }
    
    // 显示表格详情模态框
    function showTableDetailModal(title, details) {
        // 检查是否已存在模态框
        let modal = document.getElementById('tableDetailModal');
        if (!modal) {
            // 创建模态框
            modal = document.createElement('div');
            modal.id = 'tableDetailModal';
            modal.className = 'modal fade';
            modal.innerHTML = `
                <div class="modal-dialog">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title">${title}</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                        </div>
                        <div class="modal-body" id="tableDetailContent">
                            ${details}
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">关闭</button>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        } else {
            // 更新现有模态框
            modal.querySelector('.modal-title').textContent = title;
            modal.querySelector('#tableDetailContent').innerHTML = details;
        }
        
        // 显示模态框
        const modalInstance = new bootstrap.Modal(modal);
        modalInstance.show();
    }
    
    // 更新血糖图表
    function updateGlucoseChart(glucoseData, treatmentData = [], activityData = []) {
        const ctx = document.getElementById('glucoseChart').getContext('2d');
        
        if (glucoseChart) {
            glucoseChart.destroy();
        }
        
        // 检查缩放插件是否可用 - 仅用于日志记录
        const zoomPluginAvailable = typeof Chart !== 'undefined' && Chart.version;
        let pluginStatus = '检查失败';
        
        if (zoomPluginAvailable) {
            try {
                pluginStatus = Chart.registry && Chart.registry.plugins && 
                                (Chart.registry.plugins.items.some(p => p.id === 'zoom') || 
                                 Object.keys(Chart.registry.plugins.items).some(key => Chart.registry.plugins.items[key].id === 'zoom')) 
                                ? '✅ 可用' : '❌ 不可用';
            } catch (error) {
                pluginStatus = '⚠️ 检查异常';
            }
        }
        
        console.log('Chart.js版本:', Chart.version || '未加载');
        console.log('缩放插件状态:', pluginStatus);
        console.log('缩放功能将始终启用，插件不可用时会被忽略');
        
        const labels = glucoseData.map(item => item.time).reverse();
        const values = glucoseData.map(item => item.value_mmol).reverse();
        
        // 处理餐食数据 - 转换为图表数据点
        const mealDataPoints = [];
        console.log('餐食数据:', treatmentData);
        console.log('血糖时间标签:', labels);
        treatmentData.forEach(meal => {
            if (meal.carbs > 0) { // 只显示有碳水化合物的餐食记录
                const mealTime = meal.time;
                console.log(`餐食时间: ${mealTime}, 是否存在精确匹配: ${labels.includes(mealTime)}`);
                
                // 尝试精确匹配
                let mealIndex = labels.indexOf(mealTime);
                let glucoseValue = null;
                
                // 如果精确匹配失败，尝试找到最接近的时间点（前后5分钟内）
                if (mealIndex === -1) {
                    console.log(`精确匹配失败，尝试模糊匹配餐食时间: ${mealTime}`);
                    const mealDateTime = new Date(mealTime);
                    
                    for (let i = 0; i < labels.length; i++) {
                        const labelDateTime = new Date(labels[i]);
                        const timeDiff = Math.abs(labelDateTime - mealDateTime);
                        const timeDiffMinutes = timeDiff / (1000 * 60);
                        
                        if (timeDiffMinutes <= 5) { // 5分钟内认为匹配
                            mealIndex = i;
                            glucoseValue = values[i];
                            console.log(`找到模糊匹配: 索引${i}, 时间差${timeDiffMinutes.toFixed(1)}分钟`);
                            break;
                        }
                    }
                } else {
                    glucoseValue = values[mealIndex];
                }
                
                if (mealIndex !== -1 && glucoseValue !== null) {
                    // 将餐食图标放置在血糖曲线上方，错开显示
                    const mealIndexInArray = mealDataPoints.length;
                    const offsetValue = glucoseValue + (0.8 + (mealIndexInArray % 3) * 0.4); // 错开显示，避免重叠
                    const dataPoint = {
                        x: labels[mealIndex], // 使用血糖数据的时间点
                        y: offsetValue, // 调整后的Y坐标，在血糖曲线上方
                        originalY: glucoseValue, // 原始血糖值，用于显示
                        carbs: meal.carbs,
                        event_type: meal.event_type || '餐食',
                        original_time: mealTime // 原始餐食时间，用于调试
                    };
                    mealDataPoints.push(dataPoint);
                    console.log(`添加餐食数据点:`, dataPoint);
                }
            }
        });
        
        // 处理运动数据 - 转换为图表数据点
        const activityDataPoints = [];
        console.log('运动数据:', activityData);
        activityData.forEach(activity => {
            if (activity.duration > 0) { // 只显示有时长的运动记录
                const activityTime = activity.time;
                console.log(`运动时间: ${activityTime}, 是否存在精确匹配: ${labels.includes(activityTime)}`);
                
                // 尝试精确匹配
                let activityIndex = labels.indexOf(activityTime);
                let glucoseValue = null;
                
                // 如果精确匹配失败，尝试找到最接近的时间点（前后5分钟内）
                if (activityIndex === -1) {
                    console.log(`精确匹配失败，尝试模糊匹配运动时间: ${activityTime}`);
                    const activityDateTime = new Date(activityTime);
                    
                    for (let i = 0; i < labels.length; i++) {
                        const labelDateTime = new Date(labels[i]);
                        const timeDiff = Math.abs(labelDateTime - activityDateTime);
                        const timeDiffMinutes = timeDiff / (1000 * 60);
                        
                        if (timeDiffMinutes <= 5) { // 5分钟内认为匹配
                            activityIndex = i;
                            glucoseValue = values[i];
                            console.log(`找到模糊匹配: 索引${i}, 时间差${timeDiffMinutes.toFixed(1)}分钟`);
                            break;
                        }
                    }
                } else {
                    glucoseValue = values[activityIndex];
                }
                
                if (activityIndex !== -1 && glucoseValue !== null) {
                    // 将运动图标放置在血糖曲线下方，错开显示
                    const activityIndexInArray = activityDataPoints.length;
                    const offsetValue = Math.max(0.5, glucoseValue - (0.8 + (activityIndexInArray % 3) * 0.4)); // 错开显示，避免重叠，且不低于0.5
                    const dataPoint = {
                        x: labels[activityIndex], // 使用血糖数据的时间点
                        y: offsetValue, // 调整后的Y坐标，在血糖曲线下方
                        originalY: glucoseValue, // 原始血糖值，用于显示
                        duration: activity.duration,
                        event_type: activity.event_type || '运动',
                        notes: activity.notes || '', // 添加备注字段
                        original_time: activityTime // 原始运动时间，用于调试
                    };
                    activityDataPoints.push(dataPoint);
                    console.log(`添加运动数据点:`, dataPoint);
                }
            }
        });
        
        // 处理餐后两小时血糖数据 - 基于餐食记录创建餐后血糖点
        const postMealDataPoints = [];
        console.log('开始处理餐后两小时血糖数据...');
        mealDataPoints.forEach(mealPoint => {
            const mealTime = new Date(mealPoint.x);
            const postMealTime = new Date(mealTime.getTime() + 2 * 60 * 60 * 1000); // 餐后两小时
            
            // 格式化为与原始数据相同的格式，避免UTC转换问题
            const year = postMealTime.getFullYear();
            const month = String(postMealTime.getMonth() + 1).padStart(2, '0');
            const day = String(postMealTime.getDate()).padStart(2, '0');
            const hours = String(postMealTime.getHours()).padStart(2, '0');
            const minutes = String(postMealTime.getMinutes()).padStart(2, '0');
            const seconds = String(postMealTime.getSeconds()).padStart(2, '0');
            const postMealTimeStr = `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
            
            console.log(`餐食时间: ${mealPoint.x}, 餐后两小时时间: ${postMealTimeStr}`);
            
            // 在血糖数据中查找餐后两小时时间点的血糖值
            let postMealIndex = -1;
            let postMealGlucoseValue = null;
            
            // 尝试精确匹配
            postMealIndex = labels.indexOf(postMealTimeStr);
            
            // 如果精确匹配失败，尝试找到最接近的时间点（前后10分钟内）
            if (postMealIndex === -1) {
                console.log(`精确匹配失败，尝试模糊匹配餐后时间: ${postMealTimeStr}`);
                const postMealDateTime = new Date(postMealTimeStr);
                
                for (let i = 0; i < labels.length; i++) {
                    const labelDateTime = new Date(labels[i]);
                    const timeDiff = Math.abs(labelDateTime - postMealDateTime);
                    const timeDiffMinutes = timeDiff / (1000 * 60);
                    
                    if (timeDiffMinutes <= 10) { // 10分钟内认为匹配
                        postMealIndex = i;
                        postMealGlucoseValue = values[i];
                        console.log(`找到餐后血糖模糊匹配: 索引${i}, 时间差${timeDiffMinutes.toFixed(1)}分钟`);
                        break;
                    }
                }
            } else {
                postMealGlucoseValue = values[postMealIndex];
            }
            
            if (postMealIndex !== -1 && postMealGlucoseValue !== null) {
                // 将餐后血糖图标放置在血糖曲线上方，与餐食图标错开显示
                const postMealIndexInArray = postMealDataPoints.length;
                const offsetValue = postMealGlucoseValue + (1.2 + (postMealIndexInArray % 3) * 0.4); // 错开显示，避免重叠
                const dataPoint = {
                    x: labels[postMealIndex], // 使用血糖数据的时间点
                    y: offsetValue, // 调整后的Y坐标，在血糖曲线上方
                    originalY: postMealGlucoseValue, // 原始血糖值，用于显示
                    mealCarbs: mealPoint.carbs, // 关联的餐食碳水数据
                    mealEventType: mealPoint.event_type, // 关联的餐食类型
                    mealTime: mealPoint.x, // 原始餐食时间
                    postMealTime: postMealTimeStr, // 餐后时间
                    type: 'post_meal' // 标识为餐后血糖数据点
                };
                postMealDataPoints.push(dataPoint);
                console.log(`添加餐后血糖数据点:`, dataPoint);
            } else {
                console.log(`未找到餐后两小时的血糖数据，餐食时间: ${mealPoint.x}`);
            }
        });
        
        console.log('最终餐食数据点:', mealDataPoints);
        console.log('最终运动数据点:', activityDataPoints);
        console.log('最终餐后血糖数据点:', postMealDataPoints);
        
        console.log('开始创建图表，餐食数据点数量:', mealDataPoints.length);
        console.log('开始创建图表，运动数据点数量:', activityDataPoints.length);
        console.log('开始创建图表，餐后血糖数据点数量:', postMealDataPoints.length);
        console.log('餐食数据点示例:', mealDataPoints.slice(0, 2));
        console.log('运动数据点示例:', activityDataPoints.slice(0, 2));
        console.log('餐后血糖数据点示例:', postMealDataPoints.slice(0, 2));
        
        // 创建自定义插件来绘制垂直虚线
        const verticalLinePlugin = {
            id: 'verticalLinePlugin',
            afterDraw: function(chart) {
                const ctx = chart.ctx;
                const xScale = chart.scales.x;
                const yScale = chart.scales.y;
                
                // 合并所有需要绘制虚线的数据点
                const allDataPoints = [
                    ...mealDataPoints.map(point => ({...point, type: 'meal', color: '#fd7e14'})),
                    ...activityDataPoints.map(point => ({...point, type: 'activity', color: '#20c997'})),
                    ...postMealDataPoints.map(point => ({...point, type: 'post_meal', color: '#dc3545'}))
                ];
                
                allDataPoints.forEach(dataPoint => {
                    // 找到对应时间点的索引
                    const xIndex = labels.indexOf(dataPoint.x);
                    if (xIndex !== -1) {
                        const x = xScale.getPixelForValue(xIndex);
                        const y = yScale.getPixelForValue(dataPoint.y);
                        const bottomY = chart.scales.y.bottom; // 图表底部
                        
                        // 绘制垂直虚线
                        ctx.save();
                        ctx.strokeStyle = dataPoint.color;
                        ctx.lineWidth = 1;
                        ctx.setLineDash([5, 5]); // 虚线样式
                        ctx.globalAlpha = 0.6;
                        
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(x, bottomY);
                        ctx.stroke();
                        
                        ctx.restore();
                    }
                });
            }
        };
        
        // 创建图表并添加事件监听
        glucoseChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [{
                    label: '血糖值 (mmol/L)',
                    data: values,
                    borderColor: '#007bff',
                    backgroundColor: 'rgba(0, 123, 255, 0.1)',
                    tension: 0.1,
                    pointRadius: 3,
                    pointHoverRadius: 5
                }, {
                    label: '目标范围上限',
                    data: new Array(labels.length).fill(10.0),
                    borderColor: '#28a745',
                    borderDash: [5, 5],
                    pointRadius: 0,
                    fill: false
                }, {
                    label: '目标范围下限',
                    data: new Array(labels.length).fill(3.9),
                    borderColor: '#28a745',
                    borderDash: [5, 5],
                    pointRadius: 0,
                    fill: false
                }, {
                    label: '餐食记录',
                    data: mealDataPoints,
                    backgroundColor: '#fd7e14',
                    borderColor: '#fd7e14',
                    showLine: false,
                    pointRadius: 10,
                    pointHoverRadius: 12,
                    pointStyle: 'triangle',
                    rotation: 0
                }, {
                    label: '运动记录',
                    data: activityDataPoints,
                    backgroundColor: '#20c997',
                    borderColor: '#20c997',
                    showLine: false,
                    pointRadius: 10,
                    pointHoverRadius: 12,
                    pointStyle: 'rectRot',
                    rotation: 45
                }, {
                    label: '餐后血糖',
                    data: postMealDataPoints,
                    backgroundColor: '#dc3545',
                    borderColor: '#dc3545',
                    showLine: false,
                    pointRadius: 10,
                    pointHoverRadius: 12,
                    pointStyle: 'star',
                    rotation: 0
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    intersect: true,
                    mode: 'nearest'
                },
                // 缩放插件配置 - 总是启用，如果插件不可用会自动忽略
                plugins: {
                    zoom: {
                        zoom: {
                            wheel: {
                                enabled: true,
                                speed: 0.1
                            },
                            pinch: {
                                enabled: true
                            },
                            mode: 'x',
                            sensitivity: 0.3,
                            onZoomComplete: function({chart}) {
                                console.log('缩放完成，当前范围:', chart.scales.x.min, '至', chart.scales.x.max);
                            },
                            onZoomRejected: function() {
                                console.log('缩放被拒绝');
                            }
                        },
                        pan: {
                            enabled: true,
                            mode: 'x',
                            modifierKey: null,
                            threshold: 10,
                            onPanComplete: function({chart}) {
                                console.log('平移完成，当前范围:', chart.scales.x.min, '至', chart.scales.x.max);
                            },
                            onPanRejected: function() {
                                console.log('平移被拒绝');
                            }
                        },
                        limits: {
                            x: {
                                min: 'original',
                                max: 'original',
                                minRange: 2
                            }
                        }
                    },
                    // 注册自定义插件
                    ...[verticalLinePlugin],
                    legend: {
                        display: true,
                        position: window.innerWidth < 768 ? 'bottom' : 'top',
                        labels: {
                            font: {
                                size: window.innerWidth < 768 ? 10 : 12
                            },
                            usePointStyle: true,
                            padding: window.innerWidth < 768 ? 10 : 20
                        }
                    },
                    tooltip: {
                        backgroundColor: 'rgba(0,0,0,0.8)',
                        titleFont: {
                            size: window.innerWidth < 768 ? 12 : 14
                        },
                        bodyFont: {
                            size: window.innerWidth < 768 ? 11 : 13
                        },
                        padding: window.innerWidth < 768 ? 8 : 12,
                        callbacks: {
                            title: function(tooltipItems) {
                                console.log('=== Title回调调用 ===');
                                console.log('tooltipItems:', tooltipItems);
                                
                                if (!tooltipItems || tooltipItems.length === 0) {
                                    console.log('tooltipItems为空');
                                    return '';
                                }
                                
                                const tooltipItem = tooltipItems[0];
                                console.log('tooltipItem:', tooltipItem);
                                
                                const datasetIndex = tooltipItem.datasetIndex;
                                const dataIndex = tooltipItem.dataIndex;
                                const dataset = tooltipItem.chart.data.datasets[datasetIndex];
                                const dataPoint = dataset.data[dataIndex];
                                
                                console.log('datasetIndex:', datasetIndex, 'dataIndex:', dataIndex);
                                console.log('dataPoint:', dataPoint);
                                
                                if (datasetIndex === 3 && dataPoint && dataPoint.originalY !== undefined) {
                                    console.log('返回餐食标题');
                                    return `🍽️ 餐食记录`;
                                } else if (datasetIndex === 4 && dataPoint && dataPoint.originalY !== undefined) {
                                    console.log('返回运动标题');
                                    return `🏃 运动记录`;
                                } else if (datasetIndex === 5 && dataPoint && dataPoint.originalY !== undefined) {
                                    console.log('返回餐后血糖标题');
                                    return `⭐ 餐后血糖`;
                                }
                                
                                console.log('返回默认标题:', dataset.label);
                                return dataset.label;
                            },
                            label: function(context) {
                                const datasetIndex = context.datasetIndex;
                                const dataIndex = context.dataIndex;
                                const dataset = context.chart.data.datasets[datasetIndex];
                                const dataPoint = dataset.data[dataIndex];
                                
                                if (datasetIndex === 3 && dataPoint && dataPoint.originalY !== undefined) {
                                    return [
                                        `碳水: ${dataPoint.carbs}g`,
                                        `类型: ${dataPoint.event_type}`,
                                        `血糖: ${dataPoint.originalY.toFixed(1)} mmol/L`
                                    ];
                                } else if (datasetIndex === 4 && dataPoint && dataPoint.originalY !== undefined) {
                                    console.log('=== 运动工具提示调试 ===');
                                    console.log('数据点:', dataPoint);
                                    
                                    const exerciseType = dataPoint.event_type || '运动';
                                    const exerciseNotes = dataPoint.notes || '';
                                    
                                    console.log('运动类型:', exerciseType);
                                    console.log('运动备注:', exerciseNotes);
                                    
                                    // 构建显示内容，与运动记录表格保持一致
                                    const durationDisplay = dataPoint.duration > 0 ? `${dataPoint.duration}分钟` : '';
                                    const typeDisplay = exerciseType;
                                    
                                    // 如果event_type中包含" - "，则前面部分为类型，后面部分为备注
                                    let notesDisplay = exerciseNotes;
                                    if (!notesDisplay && exerciseType.includes(' - ')) {
                                        const parts = exerciseType.split(' - ');
                                        if (parts.length > 1) {
                                            notesDisplay = parts.slice(1).join(' - ');
                                        }
                                    }
                                    
                                    console.log('最终备注显示:', notesDisplay);
                                    
                                    // 先尝试简单的字符串返回
                                    let simpleResult = `时长: ${durationDisplay} | 类型: ${typeDisplay}`;
                                    if (notesDisplay && notesDisplay.trim() !== '') {
                                        simpleResult += ` | 备注: ${notesDisplay}`;
                                    }
                                    simpleResult += ` | 血糖: ${dataPoint.originalY.toFixed(1)} mmol/L`;
                                    
                                    console.log('简单结果字符串:', simpleResult);
                                    
                                    // 再尝试数组格式
                                    const result = [`时长: ${durationDisplay}`, `类型: ${typeDisplay}`];
                                    if (notesDisplay && notesDisplay.trim() !== '') {
                                        result.push(`备注: ${notesDisplay}`);
                                        console.log('添加备注行:', notesDisplay);
                                    } else {
                                        console.log('备注为空，不添加');
                                    }
                                    
                                    console.log('数组结果:', result);
                                    
                                    // 临时返回简单字符串进行测试
                                    return simpleResult;
                                } else if (datasetIndex === 5 && dataPoint && dataPoint.originalY !== undefined) {
                                    console.log('=== 餐后血糖工具提示调试 ===');
                                    console.log('数据点:', dataPoint);
                                    
                                    return [
                                        `餐后血糖: ${dataPoint.originalY.toFixed(1)} mmol/L`,
                                        `对应餐食: ${dataPoint.mealCarbs}g碳水`,
                                        `餐食类型: ${dataPoint.mealEventType}`,
                                        `餐食时间: ${dataPoint.mealTime}`,
                                        `测量时间: ${dataPoint.postMealTime}`
                                    ];
                                }
                                
                                const timeLabel = context.label;
                                return `${dataset.label}: ${context.parsed.y.toFixed(1)} mmol/L\n时间: ${timeLabel}`;
                            },
                            afterLabel: function(context) {
                                const datasetIndex = context.datasetIndex;
                                const dataIndex = context.dataIndex;
                                const dataset = context.chart.data.datasets[datasetIndex];
                                const dataPoint = dataset.data[dataIndex];
                                
                                if (datasetIndex === 3 && dataPoint && dataPoint.originalY !== undefined) {
                                    return `时间: ${dataPoint.original_time}`;
                                } else if (datasetIndex === 4 && dataPoint && dataPoint.originalY !== undefined) {
                                    return `时间: ${dataPoint.original_time}`;
                                }
                                
                                return '';
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: false,
                        min: Math.min(3.0, Math.min(...values) - 1),
                        max: Math.max(15.0, Math.max(...values) + 1),
                        grid: {
                            color: 'rgba(0,0,0,0.1)'
                        },
                        ticks: {
                            font: {
                                size: window.innerWidth < 768 ? 10 : 12
                            }
                        }
                    },
                    x: {
                        type: 'category',
                        bounds: 'data', // 允许显示超出数据边界的范围
                        ticks: {
                            maxTicksLimit: window.innerWidth < 768 ? 6 : 10,
                            font: {
                                size: window.innerWidth < 768 ? 10 : 12
                            },
                            maxRotation: window.innerWidth < 768 ? 45 : 0
                        },
                        grid: {
                            color: 'rgba(0,0,0,0.1)'
                        }
                    }
                }
            }
        });
        
        // 移动端触摸优化
        setupMobileOptimizations(glucoseChart);
        
        // 锚点拖动优化
        setupAnchorPointDragging(glucoseChart);
        
        console.log('图表创建完成，移动端和PC端优化已配置');
    }
    
    // 移动端触摸优化设置
    function setupMobileOptimizations(chart) {
        if (!chart) return;
        
        const canvas = chart.canvas;
        const container = canvas.closest('.chart-container');
        
        if (!container) return;
        
        // 添加触摸事件监听器
        let touchStartTime = 0;
        let touchStartDistance = 0;
        let isZooming = false;
        let isPanning = false;
        
        // 触摸开始
        canvas.addEventListener('touchstart', function(e) {
            const now = Date.now();
            touchStartTime = now;
            
            if (e.touches.length === 2) {
                // 双指触摸 - 缩放
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                touchStartDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                isZooming = true;
                container.classList.add('zooming');
                console.log('开始双指缩放');
            } else if (e.touches.length === 1) {
                // 单指触摸 - 平移
                isPanning = true;
                console.log('开始单指平移');
            }
            
            e.preventDefault();
        }, { passive: false });
        
        // 触摸移动
        canvas.addEventListener('touchmove', function(e) {
            if (isZooming && e.touches.length === 2) {
                // 处理缩放
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                const currentDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                
                const scale = currentDistance / touchStartDistance;
                const zoomLevel = scale > 1 ? 1.1 : 0.9;
                
                try {
                    chart.zoom(zoomLevel);
                    console.log('触摸缩放:', scale);
                } catch (error) {
                    console.error('触摸缩放失败:', error);
                }
                
                touchStartDistance = currentDistance;
            } else if (isPanning && e.touches.length === 1) {
                // 处理平移 - 让Chart.js插件处理
                console.log('触摸平移中...');
            }
            
            e.preventDefault();
        }, { passive: false });
        
        // 触摸结束
        canvas.addEventListener('touchend', function(e) {
            const touchDuration = Date.now() - touchStartTime;
            
            if (isZooming) {
                console.log('双指缩放结束');
            } else if (isPanning) {
                console.log('单指平移结束');
            }
            
            isZooming = false;
            isPanning = false;
            container.classList.remove('zooming');
            
            e.preventDefault();
        }, { passive: false });
        
        // 防止默认的触摸行为
        canvas.addEventListener('touchstart', function(e) {
            e.preventDefault();
        }, { passive: false });
        
        console.log('移动端触摸优化已配置');
    }
    
    // 锚点拖动系统
    class AnchorPointDragSystem {
        constructor(chart) {
            this.chart = chart;
            this.canvas = chart.canvas;
            this.container = this.canvas.closest('.chart-container');
            this.isActive = false;
            this.anchorPoint = null;
            this.startX = 0;
            this.startY = 0;
            this.anchorTimeValue = null;
            this.anchorPixelPosition = 0;
            this.originalTimeRange = null;
            
            // 保存绑定的函数引用以避免内存泄漏
            this.boundHandleStart = this.handleStart.bind(this);
            this.boundHandleMove = this.handleMove.bind(this);
            this.boundHandleEnd = this.handleEnd.bind(this);
            
            this.initializeAnchorPoint();
            this.bindEvents();
        }
        
        initializeAnchorPoint() {
            // 创建锚点视觉指示器
            this.anchorPoint = document.createElement('div');
            this.anchorPoint.className = 'chart-anchor-point';
            this.anchorPoint.style.display = 'none';
            this.container.appendChild(this.anchorPoint);
        }
        
        bindEvents() {
            // PC端事件
            this.canvas.addEventListener('mousedown', this.boundHandleStart);
            document.addEventListener('mousemove', this.boundHandleMove);
            document.addEventListener('mouseup', this.boundHandleEnd);
            
            // 移动端事件
            this.canvas.addEventListener('touchstart', this.boundHandleStart, { passive: false });
            document.addEventListener('touchmove', this.boundHandleMove, { passive: false });
            document.addEventListener('touchend', this.boundHandleEnd);
        }
        
        handleStart(e) {
            // 只处理左键或单指触摸
            if (e.type === 'mousedown' && e.button !== 0) return;
            if (e.type === 'touchstart' && e.touches.length !== 1) return;
            
            e.preventDefault();
            
            const clientX = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
            const clientY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;
            
            this.startX = clientX;
            this.startY = clientY;
            this.isActive = true;
            
            // 计算点击位置对应的时间值
            this.anchorTimeValue = this.getTimeFromCanvasPosition(clientX);
            this.anchorPixelPosition = this.getRelativeCanvasPosition(clientX);
            
            // 保存原始时间范围
            this.originalTimeRange = {
                min: this.chart.scales.x.min,
                max: this.chart.scales.x.max
            };
            
            // 显示锚点指示器
            this.showAnchorPoint(clientX, clientY);
            
            // 添加触摸反馈样式
            this.addTouchFeedback();
            
            // 仅在开发环境中输出详细日志
            if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
                console.log('锚点拖动开始:', {
                    anchorTime: this.anchorTimeValue,
                    pixelPosition: this.anchorPixelPosition,
                    originalRange: this.originalTimeRange
                });
            }
        }
        
        handleMove(e) {
            if (!this.isActive) return;
            
            e.preventDefault();
            
            const clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
            const deltaX = clientX - this.startX;
            
            // 计算新的图表范围
            const newRange = this.calculateNewRange(deltaX);
            
            // 更新图表范围（仅在newRange有效时）
            if (newRange) {
                this.updateChartRange(newRange);
            }
            
            // 更新锚点位置
            this.updateAnchorPosition(clientX);
        }
        
        handleEnd(e) {
            if (!this.isActive) return;
            
            this.isActive = false;
            
            // 隐藏锚点指示器
            this.hideAnchorPoint();
            
            // 移除触摸反馈样式
            this.removeTouchFeedback();
            
            // 仅在开发环境中输出日志
            if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
                console.log('锚点拖动结束');
            }
        }
        
        getTimeFromCanvasPosition(clientX) {
            const rect = this.canvas.getBoundingClientRect();
            const x = clientX - rect.left;
            const canvasWidth = rect.width;
            
            // 计算在画布上的相对位置 (0-1)
            const relativePosition = x / canvasWidth;
            
            // 获取当前图表的时间范围
            const timeScale = this.chart.scales.x;
            const minTime = timeScale.min;
            const maxTime = timeScale.max;
            
            // 计算对应的时间值
            const timeValue = minTime + (maxTime - minTime) * relativePosition;
            
            return new Date(timeValue);
        }
        
        getRelativeCanvasPosition(clientX) {
            const rect = this.canvas.getBoundingClientRect();
            const x = clientX - rect.left;
            const canvasWidth = rect.width;
            
            return x / canvasWidth; // 返回相对位置 (0-1)
        }
        
        getTimeRange() {
            // 计算原始时间范围的跨度
            if (!this.originalTimeRange || typeof this.originalTimeRange.min !== 'number' || typeof this.originalTimeRange.max !== 'number') {
                return 0;
            }
            return this.originalTimeRange.max - this.originalTimeRange.min;
        }
        
        calculateNewRange(deltaX) {
            // 边界检查：确保原始时间范围存在
            if (!this.originalTimeRange) {
                console.warn('原始时间范围不存在');
                return null;
            }
            
            const canvasWidth = this.canvas.getBoundingClientRect().width;
            const timeRange = this.getTimeRange();
            
            // 边界检查：确保画布宽度和时间范围有效
            if (canvasWidth <= 0 || timeRange <= 0) {
                console.warn('无效的画布宽度或时间范围:', { canvasWidth, timeRange });
                return null;
            }
            
            // 计算拖动距离对应的时间变化
            const timeDelta = (deltaX / canvasWidth) * timeRange;
            
            // 计算新的时间范围，使锚点跟随手指
            const newMin = this.originalTimeRange.min - timeDelta;
            const newMax = this.originalTimeRange.max - timeDelta;
            
            return {
                min: newMin,
                max: newMax
            };
        }
        
        updateChartRange(newRange) {
            try {
                // 边界检查：确保newRange对象存在且包含min和max属性
                if (!newRange || typeof newRange.min !== 'number' || typeof newRange.max !== 'number') {
                    console.warn('无效的时间范围参数:', newRange);
                    return;
                }
                
                // 边界检查：确保最小值小于最大值
                if (newRange.min >= newRange.max) {
                    console.warn('时间范围无效：最小值必须小于最大值', newRange);
                    return;
                }
                
                // 边界检查：确保图表和其选项存在
                if (!this.chart || !this.chart.options || !this.chart.options.scales || !this.chart.options.scales.x) {
                    console.warn('图表对象或其选项不存在');
                    return;
                }
                
                // 直接更新图表的时间范围
                this.chart.options.scales.x.min = newRange.min;
                this.chart.options.scales.x.max = newRange.max;
                this.chart.update('none'); // 无动画更新以提高性能
                
            } catch (error) {
                console.error('更新图表范围时发生错误:', error);
                // 不抛出错误，避免影响用户体验
            }
        }
        
        showAnchorPoint(clientX, clientY) {
            const rect = this.canvas.getBoundingClientRect();
            const x = clientX - rect.left;
            const y = clientY - rect.top;
            
            this.anchorPoint.style.left = x + 'px';
            this.anchorPoint.style.top = y + 'px';
            this.anchorPoint.style.display = 'block';
            this.anchorPoint.classList.add('active');
        }
        
        updateAnchorPosition(clientX) {
            const rect = this.canvas.getBoundingClientRect();
            const x = clientX - rect.left;
            
            this.anchorPoint.style.left = x + 'px';
        }
        
        hideAnchorPoint() {
            this.anchorPoint.style.display = 'none';
            this.anchorPoint.classList.remove('active');
        }
        
        addTouchFeedback() {
            this.container.classList.add('touch-active', 'touch-pressing');
            this.canvas.classList.add('touch-active');
        }
        
        removeTouchFeedback() {
            this.container.classList.remove('touch-active', 'touch-pressing');
            this.canvas.classList.remove('touch-active');
        }
        
        destroy() {
            // 清理事件监听器
            this.canvas.removeEventListener('mousedown', this.boundHandleStart);
            document.removeEventListener('mousemove', this.boundHandleMove);
            document.removeEventListener('mouseup', this.boundHandleEnd);
            this.canvas.removeEventListener('touchstart', this.boundHandleStart);
            document.removeEventListener('touchmove', this.boundHandleMove);
            document.removeEventListener('touchend', this.boundHandleEnd);
            
            // 移除锚点元素
            if (this.anchorPoint && this.anchorPoint.parentNode) {
                this.anchorPoint.parentNode.removeChild(this.anchorPoint);
            }
        }
    }
    
    // 替换现有的setupPcPanOptimizations函数
    function setupAnchorPointDragging(chart) {
        if (!chart) return;
        
        // 清理现有的拖动系统
        if (chart.anchorDragSystem) {
            chart.anchorDragSystem.destroy();
        }
        
        // 创建新的锚点拖动系统
        chart.anchorDragSystem = new AnchorPointDragSystem(chart);
        
        // 仅在开发环境中输出日志
        if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
            console.log('锚点拖动系统已初始化');
        }
    }
    
    // 重置图表缩放
    function resetChartZoom() {
        if (glucoseChart) {
            try {
                glucoseChart.resetZoom();
                console.log('图表缩放重置成功');
            } catch (error) {
                console.error('重置缩放失败:', error);
            }
        } else {
            console.log('图表不存在，无法重置缩放');
        }
    }
    
    // 获取AI分析
    function getAnalysis() {
        const modal = new bootstrap.Modal(document.getElementById('analysisModal'));
        modal.show();
        
        document.getElementById('analysis-content').innerHTML = `
            <div class="text-center">
                <i class="fas fa-spinner fa-spin"></i> 分析中，请稍候...
            </div>
        `;
        
        fetch(`/api/analysis?days=${currentDays}`)
            .then(response => response.json())
            .then(data => {
                if (data.analysis) {
                    document.getElementById('analysis-content').innerHTML = `
                        <div class="alert alert-info">
                            <h6><i class="fas fa-info-circle"></i> 分析结果</h6>
                            <div class="ai-analysis">${parseMarkdown(data.analysis)}</div>
                        </div>
                    `;
                } else {
                    document.getElementById('analysis-content').innerHTML = `
                        <div class="alert alert-danger">
                            <h6><i class="fas fa-exclamation-triangle"></i> 分析失败</h6>
                            <p>${data.error || '未知错误'}</p>
                        </div>
                    `;
                }
            })
            .catch(error => {
                document.getElementById('analysis-content').innerHTML = `
                    <div class="alert alert-danger">
                        <h6><i class="fas fa-exclamation-triangle"></i> 分析失败</h6>
                        <p>网络错误: ${error.message}</p>
                    </div>
                `;
            });
    }
    
    // 复制分析结果
    function copyAnalysis() {
        const content = document.querySelector('#analysis-content pre');
        if (content) {
            navigator.clipboard.writeText(content.textContent).then(() => {
                console.log('分析结果已复制到剪贴板');
            });
        }
    }
    

    // 打开AI咨询模态框
    function openAIConsult() {
        const modal = new bootstrap.Modal(document.getElementById('consultModal'));
        modal.show();

        // 清空之前的内容
        document.getElementById('consultQuestion').value = '';
        document.getElementById('consult-response').style.display = 'none';
        document.getElementById('copyConsultBtn').style.display = 'none';
        document.getElementById('consultSubmitBtn').disabled = false;
    }

    // 提交AI咨询
    function submitConsult() {
        const question = document.getElementById('consultQuestion').value.trim();
        const includeData = document.getElementById('includeGlucoseData').checked;
        const submitBtn = document.getElementById('consultSubmitBtn');
        const originalText = submitBtn.innerHTML;

        if (!question) {
            showNotification('请输入您的问题', 'warning');
            return;
        }

        // 显示加载状态
        submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> 咨询中...';
        submitBtn.disabled = true;

        // 显示回复区域
        document.getElementById('consult-response').style.display = 'block';
        document.getElementById('consult-content').innerHTML = `
            <div class="text-center">
                <i class="fas fa-spinner fa-spin"></i> AI正在思考中，请稍候...
            </div>
        `;

        // 构建请求数据
        const requestData = {
            question: question,
            include_data: includeData,
            days: currentDays
        };

        fetch('/api/ai-consult', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(requestData)
        })
        .then(response => response.json())
        .then(data => {
            if (data.response) {
                document.getElementById('consult-content').innerHTML = `
                    <div class="ai-response">
                        ${parseMarkdown(data.response)}
                    </div>
                `;
                document.getElementById('copyConsultBtn').style.display = 'inline-block';
                console.log('AI咨询完成');
            } else {
                document.getElementById('consult-content').innerHTML = `
                    <div class="alert alert-danger">
                        <h6><i class="fas fa-exclamation-triangle"></i> 咨询失败</h6>
                        <p>${data.error || '未知错误'}</p>
                    </div>
                `;
                showNotification('AI咨询失败: ' + (data.error || '未知错误'), 'danger');
            }
        })
        .catch(error => {
            document.getElementById('consult-content').innerHTML = `
                <div class="alert alert-danger">
                    <h6><i class="fas fa-exclamation-triangle"></i> 咨询失败</h6>
                    <p>网络错误: ${error.message}</p>
                </div>
            `;
            showNotification('咨询失败: ' + error.message, 'danger');
        })
        .finally(() => {
            submitBtn.innerHTML = originalText;
            submitBtn.disabled = false;
        });
    }

    // 复制AI咨询回复
    function copyConsultResponse() {
        const content = document.getElementById('consult-content').innerText;
        navigator.clipboard.writeText(content).then(() => {
            console.log('回复已复制到剪贴板');
        }).catch(() => {
            showNotification('复制失败，请手动选择复制', 'warning');
        });
    }

    // 生成报表
    function generateReport() {
        const startDate = document.getElementById('startDate').value;
        const endDate = document.getElementById('endDate').value;
        
        let reportUrl = '/report';
        
        if (startDate && endDate) {
            // 使用自定义日期范围
            if (new Date(startDate) > new Date(endDate)) {
                showNotification('开始日期不能晚于结束日期', 'warning');
                return;
            }
            reportUrl += `?start_date=${startDate}&end_date=${endDate}`;
        } else {
            // 使用当前天数
            const today = new Date().toISOString().split('T')[0];
            const startDate = new Date();
            startDate.setDate(startDate.getDate() - (currentDays - 1));
            const startDateStr = startDate.toISOString().split('T')[0];
            reportUrl += `?start_date=${startDateStr}&end_date=${today}`;
        }
        
        // 在新窗口打开报表页面
        window.open(reportUrl, '_blank');
    }
    
    // 打开消息收件箱
    function openMessageInbox() {
        window.open('/messages', '_blank');
    }
    
    // 更新未读消息数量指示器
    function updateUnreadCountIndicator() {
        fetch('/api/messages/unread-count')
            .then(response => response.json())
            .then(data => {
                const messageBtn = document.querySelector('button[onclick="openMessageInbox()"]');
                if (messageBtn && data.unread_count > 0) {
                    // 移除可能已存在的红点
                    const existingBadge = messageBtn.querySelector('.unread-badge');
                    if (existingBadge) {
                        existingBadge.remove();
                    }
                    
                    // 添加新的红点
                    const badge = document.createElement('span');
                    badge.className = 'position-absolute top-0 start-100 translate-middle badge rounded-pill bg-danger unread-badge';
                    badge.textContent = data.unread_count > 99 ? '99+' : data.unread_count;
                    messageBtn.appendChild(badge);
                    messageBtn.classList.add('position-relative');
                }
            })
            .catch(error => {
                console.error('获取未读消息数量失败:', error);
            });
    }
    
    // 更新预测显示
    function updatePredictionDisplay(prediction, risk_assessment) {
        const predictedGlucoseEl = document.getElementById('predicted-glucose');
        const confidenceEl = document.getElementById('prediction-confidence');
        const riskIndicatorEl = document.getElementById('risk-indicator');
        
        if (!predictedGlucoseEl || !confidenceEl || !riskIndicatorEl) {
            return;
        }
        
        // 显示"预测"信息
        predictedGlucoseEl.textContent = '预测';
        predictedGlucoseEl.className = 'mb-2 text-primary';
        
        // 更新置信度
        const confidenceBadge = confidenceEl.querySelector('.badge');
        if (confidenceBadge) {
            const confidenceText = `置信度 ${prediction.confidence_score}%`;
            confidenceBadge.textContent = confidenceText;
            
            // 更新置信度颜色
            if (prediction.confidence_score >= 80) {
                confidenceBadge.className = 'badge bg-success';
            } else if (prediction.confidence_score >= 60) {
                confidenceBadge.className = 'badge bg-warning';
            } else {
                confidenceBadge.className = 'badge bg-danger';
            }
        } else {
            // 备用方案：直接创建badge元素
            confidenceEl.innerHTML = `<small class="badge ${getConfidenceBadgeClass(prediction.confidence_score)}">置信度 ${prediction.confidence_score}%</small>`;
        }
        
        // 添加预测趋势信息
        if (prediction.prediction_points && prediction.prediction_points.length > 0) {
            const trendText = getTrendDescription(prediction.prediction_points);
            const trendEl = document.createElement('div');
            trendEl.className = 'mt-2';
            trendEl.innerHTML = `<small class="text-info"><i class="fas fa-chart-line"></i> ${trendText}</small>`;
            
            // 移除旧的趋势信息
            const oldTrendEl = confidenceEl.parentElement.querySelector('.text-info');
            if (oldTrendEl) {
                oldTrendEl.remove();
            }
            
            // 添加新的趋势信息
            confidenceEl.parentElement.appendChild(trendEl);
        }
        
        // 更新风险指示器
        const riskBadge = riskIndicatorEl.querySelector('.badge');
        if (riskBadge) {
            riskBadge.textContent = getRiskText(risk_assessment.risk_level);
            
            // 更新风险指示器颜色
            if (risk_assessment.risk_level === 'HIGH') {
                riskBadge.className = 'badge bg-danger';
            } else if (risk_assessment.risk_level === 'MEDIUM') {
                riskBadge.className = 'badge bg-warning';
            } else {
                riskBadge.className = 'badge bg-success';
            }
        } else {
            // 备用方案：直接创建badge元素
            riskIndicatorEl.innerHTML = `<small class="badge ${getRiskBadgeClass(risk_assessment.risk_level)}">${getRiskText(risk_assessment.risk_level)}</small>`;
        }
    }
    
    // 获取风险描述文本
    function getRiskText(risk_level) {
        switch (risk_level) {
            case 'HIGH':
                return '高风险';
            case 'MEDIUM':
                return '中等风险';
            case 'LOW':
                return '低风险';
            default:
                return '未知风险';
        }
    }
    
    // 获取置信度badge类名
    function getConfidenceBadgeClass(confidence_score) {
        if (confidence_score >= 80) {
            return 'bg-success';
        } else if (confidence_score >= 60) {
            return 'bg-warning';
        } else {
            return 'bg-danger';
        }
    }
    
    // 获取风险badge类名
    function getRiskBadgeClass(risk_level) {
        switch (risk_level) {
            case 'HIGH':
                return 'bg-danger';
            case 'MEDIUM':
                return 'bg-warning';
            case 'LOW':
                return 'bg-success';
            default:
                return 'bg-secondary';
        }
    }
    
    // 获取趋势描述文本
    function getTrendDescription(prediction_points) {
        if (!prediction_points || prediction_points.length === 0) {
            return '';
        }
        
        const firstPoint = prediction_points[0];
        const lastPoint = prediction_points[prediction_points.length - 1];
        const trendChange = lastPoint.predicted_glucose_mmol - firstPoint.predicted_glucose_mmol;
        
        let trendDirection = '';
        let trendMagnitude = '';
        
        if (Math.abs(trendChange) < 0.1) {
            trendDirection = '平稳';
            trendMagnitude = '';
        } else if (trendChange > 0) {
            trendDirection = '上升';
            if (trendChange < 0.5) {
                trendMagnitude = '缓慢';
            } else if (trendChange < 1.0) {
                trendMagnitude = '中度';
            } else {
                trendMagnitude = '快速';
            }
        } else {
            trendDirection = '下降';
            if (Math.abs(trendChange) < 0.5) {
                trendMagnitude = '缓慢';
            } else if (Math.abs(trendChange) < 1.0) {
                trendMagnitude = '中度';
            } else {
                trendMagnitude = '快速';
            }
        }
        
        const trendText = trendDirection; // 直接使用趋势方向，包括"平稳"
        return `趋势预测：30分钟（${trendText}）${firstPoint.predicted_glucose_mmol} → ${lastPoint.predicted_glucose_mmol} mmol/L`;
    }
    
    // 手动预测函数
    function manualPrediction() {
        // 显示预测进行中状态
        const predictedGlucoseEl = document.getElementById('predicted-glucose');
        const confidenceEl = document.getElementById('prediction-confidence');
        const riskIndicatorEl = document.getElementById('risk-indicator');
        
        if (predictedGlucoseEl) {
            predictedGlucoseEl.textContent = '--';
        }
        if (confidenceEl) {
            confidenceEl.innerHTML = '<span class="text-muted">预测中...</span>';
        }
        if (riskIndicatorEl) {
            riskIndicatorEl.innerHTML = '<small class="badge bg-secondary">--</small>';
        }
        
        // 调用预测API
        fetch('/api/predict')
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    updatePredictionDisplay(data.prediction, data.risk_assessment);
                    console.log('预测已更新');
                } else {
                    // 显示错误信息
                    if (confidenceEl) {
                        confidenceEl.innerHTML = '<span class="text-muted">预测失败</span>';
                    }
                    showNotification('预测失败: ' + (data.error || '未知错误'), 'danger');
                }
            })
            .catch(error => {
                console.error('手动预测失败:', error);
                if (confidenceEl) {
                    confidenceEl.innerHTML = '<span class="text-muted">网络错误</span>';
                }
                showNotification('网络连接失败，请重试', 'danger');
            });
    }
    
    // 显示通知函数
    function showNotification(message, type = 'info') {
        // 创建通知元素
        const notification = document.createElement('div');
        notification.className = `alert alert-${type} alert-dismissible fade show position-fixed`;
        notification.style.cssText = 'top: 20px; right: 20px; z-index: 9999; max-width: 350px;';
        
        notification.innerHTML = `
            <div class="d-flex align-items-center">
                <i class="fas fa-${type === 'error' ? 'exclamation-triangle' : 'info-circle'} me-2"></i>
                <div>
                    <p class="mb-0">${message}</p>
                </div>
                <button type="button" class="btn-close ms-auto" data-bs-dismiss="alert"></button>
            </div>
        `;
        
        document.body.appendChild(notification);
        
        // 自动关闭
        setTimeout(() => {
            if (notification.parentNode) {
                notification.remove();
            }
        }, 5000);
    }
    
    // 显示警报
    function showAlert(risk_assessment) {
        const alertSection = document.getElementById('alert-section');
        const alertTitle = document.getElementById('alert-title');
        const alertMessage = document.getElementById('alert-message');
        const alertTime = document.getElementById('alert-time');
        
        // 设置警报内容
        alertTitle.textContent = `${getRiskText(risk_assessment.risk_level)} - 低血糖警报`;
        alertMessage.textContent = risk_assessment.risk_description;
        alertTime.textContent = `预测血糖: ${risk_assessment.predicted_glucose_mmol} mmol/L (${risk_assessment.predicted_glucose_mgdl} mg/dL)`;
        
        // 设置警报样式
        const alertEl = alertSection.querySelector('.alert');
        if (risk_assessment.risk_level === 'HIGH') {
            alertEl.className = 'alert alert-danger alert-dismissible fade show';
        } else if (risk_assessment.risk_level === 'MEDIUM') {
            alertEl.className = 'alert alert-warning alert-dismissible fade show';
        }
        
        // 显示警报
        alertSection.style.display = 'block';
        
        // 添加动画效果
        alertEl.classList.add('animate__animated', 'animate__fadeInDown');
    }
    
    // 关闭警报
    function dismissAlert() {
        const alertSection = document.getElementById('alert-section');
        alertSection.style.display = 'none';
        
        // 这里可以添加确认警报的API调用
        // acknowledgeAlert();
    }
    
    // 更新图表显示预测
    function updateChartWithPrediction(prediction) {
        console.log('=== updateChartWithPrediction 开始 ===');
        console.log('预测数据:', prediction);
        
        if (!glucoseChart) {
            console.error('图表不存在，无法更新预测数据');
            return;
        }
        
        // 获取当前图表数据
        const currentData = glucoseChart.data;
        console.log('当前图表数据标签数量:', currentData.labels.length);
        console.log('当前图表数据集数量:', currentData.datasets.length);
        
        // 计算预测点的时间基准
        const lastTime = currentData.labels[currentData.labels.length - 1];
        console.log('最后一个时间点:', lastTime);
        
        // 修复时间处理：支持多种格式，避免时区问题
        let baseTime;
        try {
            // 尝试直接解析时间字符串
            if (lastTime.includes('T')) {
                // ISO格式时间
                baseTime = new Date(lastTime);
            } else {
                // 本地格式时间
                baseTime = new Date(lastTime.replace(' ', 'T'));
            }
            
            if (isNaN(baseTime.getTime())) {
                throw new Error('时间解析失败');
            }
            
            console.log('基准时间解析成功:', baseTime.toISOString());
        } catch (error) {
            console.error('时间解析失败，使用当前时间:', error);
            baseTime = new Date();
        }
        
        // 查找现有的预测数据集
        const predictionDatasetIndex = currentData.datasets.findIndex(dataset => dataset.label === '预测走势');
        let predictionDataset;
        
        if (predictionDatasetIndex !== -1) {
            // 使用现有的预测数据集
            predictionDataset = currentData.datasets[predictionDatasetIndex];
            console.log('使用现有的预测数据集，索引:', predictionDatasetIndex);
            
            // 重置数据，为现有数据点填充null
            predictionDataset.data = new Array(currentData.labels.length).fill(null);
            // 确保数据集可见
            predictionDataset.hidden = false;
        } else {
            // 创建新的预测数据集 - 优化配置
            predictionDataset = {
                label: '预测走势',
                data: new Array(currentData.labels.length).fill(null), // 为现有数据点填充null
                borderColor: 'rgb(255, 140, 0)', // 深橙色，更醒目
                backgroundColor: 'rgba(255, 140, 0, 0.2)', // 增加背景透明度
                borderDash: [10, 5], // 优化虚线样式
                borderWidth: 3, // 增加线宽
                fill: false,
                tension: 0.4, // 增加曲线平滑度
                pointRadius: 6, // 增加点大小
                pointHoverRadius: 8, // 增加悬停点大小
                pointBackgroundColor: 'rgb(255, 140, 0)',
                pointBorderColor: '#fff',
                pointBorderWidth: 2,
                pointStyle: 'circle',
                showLine: true,
                hidden: false
            };
            console.log('创建新的预测数据集');
        }
        
        console.log('创建预测数据集:', predictionDataset);
        
        // 添加预测时间点和数据
        const predictionLabels = [];
        const predictionValues = [];
        
        if (prediction.prediction_points && prediction.prediction_points.length > 0) {
            console.log('使用多预测点数据，数量:', prediction.prediction_points.length);
            
            // 使用新的多预测点数据
            prediction.prediction_points.forEach((point, index) => {
                const predictionTime = new Date(baseTime);
                predictionTime.setMinutes(predictionTime.getMinutes() + point.minutes_ahead);
                
                // 格式化为与原始数据一致的格式
                const formattedTime = formatPredictionTime(predictionTime);
                console.log(`预测点${index + 1}: ${point.minutes_ahead}分钟后, 时间: ${formattedTime}, 血糖: ${point.predicted_glucose_mmol}`);
                
                predictionLabels.push(formattedTime);
                predictionValues.push(point.predicted_glucose_mmol);
            });
        } else {
            console.log('使用单一预测点数据');
            
            // 兼容旧的单一预测点数据
            const predictionTime = new Date(baseTime);
            predictionTime.setMinutes(predictionTime.getMinutes() + 30);
            
            const formattedTime = formatPredictionTime(predictionTime);
            console.log(`单一预测点: 30分钟后, 时间: ${formattedTime}, 血糖: ${prediction.predicted_glucose_mmol}`);
            
            predictionLabels.push(formattedTime);
            predictionValues.push(prediction.predicted_glucose_mmol);
        }
        
        console.log('生成的预测标签:', predictionLabels);
        console.log('生成的预测值:', predictionValues);
        
        // 将预测数据添加到数据集
        predictionDataset.data = predictionDataset.data.concat(predictionValues);
        
        // 将预测时间标签添加到图表
        const beforeLabelsCount = currentData.labels.length;
        currentData.labels.push(...predictionLabels);
        const afterLabelsCount = currentData.labels.length;
        console.log(`添加预测标签: ${beforeLabelsCount} -> ${afterLabelsCount}`);
        
        // 如果是新创建的数据集，则添加到图表
        if (predictionDatasetIndex === -1) {
            currentData.datasets.push(predictionDataset);
            console.log('添加新预测数据集到图表');
        }
        
        console.log('最终数据集数量:', currentData.datasets.length);
        console.log('最终标签数量:', currentData.labels.length);
        
        // 动态调整图表配置以确保预测点可见
        if (glucoseChart.options && glucoseChart.options.scales && glucoseChart.options.scales.x) {
            console.log('动态调整图表x轴配置');
            
            // 临时增加x轴的最大刻度限制以显示预测点
            const xTicksConfig = glucoseChart.options.scales.x.ticks;
            const originalMaxTicksLimit = xTicksConfig.maxTicksLimit || 10;
            
            // 根据标签数量动态调整刻度限制
            const recommendedMaxTicks = Math.min(20, Math.max(12, currentData.labels.length / 10));
            xTicksConfig.maxTicksLimit = recommendedMaxTicksLimit;
            
            console.log(`调整x轴最大刻度数从${originalMaxTicksLimit}到${recommendedMaxTicksLimit}`);
            
            // 暂时减少最大旋转角度以确保时间标签可读
            const originalMaxRotation = xTicksConfig.maxRotation || 0;
            xTicksConfig.maxRotation = 30;
            console.log(`调整x轴标签最大旋转角度从${originalMaxRotation}到30度`);
        }
        
        try {
            // 更新图表
            glucoseChart.update();
            console.log('图表更新成功');
            
            // 自动滚动图表到预测点位置
            setTimeout(() => {
                if (glucoseChart && predictionLabels.length > 0) {
                    console.log('自动滚动图表以显示预测点');
                    try {
                        // 强制图表重绘并滚动到最新数据
                        glucoseChart.update('active');
                        
                        // 获取图表的画布元素
                        const canvas = glucoseChart.canvas;
                        if (canvas) {
                            // 滚动到画布的右侧（最新数据）
                            canvas.parentElement.scrollLeft = canvas.parentElement.scrollWidth;
                            console.log('图表滚动到右侧完成');
                        }
                    } catch (error) {
                        console.error('图表滚动失败:', error);
                    }
                }
            }, 200);
            
            // 30秒后移除预测数据
            setTimeout(() => {
                if (glucoseChart && currentData.datasets) {
                    console.log('移除预测数据...');
                    
                    // 查找预测数据集
                    const datasetIndex = currentData.datasets.findIndex(dataset => dataset.label === '预测走势');
                    if (datasetIndex !== -1) {
                        // 清空预测数据而不是移除数据集
                        const predictionDataset = currentData.datasets[datasetIndex];
                        predictionDataset.data = [];
                        predictionDataset.hidden = true;
                        console.log('清空预测数据并隐藏数据集');
                        
                        // 移除预测时间标签（如果存在）
                        const beforeLabelsCount = currentData.labels.length;
                        // 找到原始数据的结束位置
                        const originalDataEndIndex = currentData.labels.length - predictionLabels.length;
                        if (originalDataEndIndex > 0) {
                            currentData.labels.splice(originalDataEndIndex, predictionLabels.length);
                            console.log(`移除预测标签: ${beforeLabelsCount} -> ${currentData.labels.length}`);
                        }
                        
                        glucoseChart.update();
                        console.log('预测数据移除完成');
                    }
                }
            }, 30000);
            
        } catch (error) {
            console.error('图表更新失败:', error);
        }
    }
    
    // 显示通知消息
    function showNotification(message, type = 'info') {
        // 创建通知元素
        const notification = document.createElement('div');
        notification.className = `alert alert-${type === 'error' ? 'danger' : type} alert-dismissible fade show position-fixed`;
        notification.style.cssText = 'top: 20px; right: 20px; z-index: 9999; max-width: 350px;';
        
        notification.innerHTML = `
            <div class="d-flex align-items-center">
                <i class="fas fa-${type === 'error' ? 'exclamation-triangle' : 'info-circle'} me-2"></i>
                <div>
                    <p class="mb-0">${message}</p>
                </div>
                <button type="button" class="btn-close ms-auto" data-bs-dismiss="alert"></button>
            </div>
        `;
        
        document.body.appendChild(notification);
        
        // 自动关闭
        setTimeout(() => {
            if (notification.parentNode) {
                notification.remove();
            }
        }, 5000);
    }
    
    // 自动血糖预测 - 页面加载时自动执行
    function loadAutomaticPrediction() {
        console.log('=== loadAutomaticPrediction 开始 ===');
        
        // 显示预测卡片加载状态
        const predictedGlucoseEl = document.getElementById('predicted-glucose');
        const confidenceEl = document.getElementById('prediction-confidence');
        const riskIndicatorEl = document.getElementById('risk-indicator');
        
        if (predictedGlucoseEl) {
            predictedGlucoseEl.textContent = '--';
            predictedGlucoseEl.className = 'mb-1 text-muted';
        }
        if (confidenceEl) {
            confidenceEl.innerHTML = '<span class="text-muted">预测中...</span>';
        }
        if (riskIndicatorEl) {
            const riskBadge = riskIndicatorEl.querySelector('.badge');
            if (riskBadge) {
                riskBadge.textContent = '预测中...';
                riskBadge.className = 'badge bg-secondary';
            }
        }
        
        console.log('发送预测请求到 /api/predict');
        
        fetch('/api/predict')
            .then(response => {
                console.log('收到预测响应，状态:', response.status);
                return response.json();
            })
            .then(data => {
                console.log('预测响应数据:', data);
                
                if (data.status === 'success') {
                    console.log('预测成功，更新显示');
                    
                    // 更新预测显示
                    updatePredictionDisplay(data.prediction, data.risk_assessment);
                    
                    // 如果有高风险或中风险，显示警报
                    if (data.risk_assessment.risk_level !== 'LOW') {
                        console.log('检测到风险，显示警报:', data.risk_assessment.risk_level);
                        showAlert(data.risk_assessment);
                    } else {
                        console.log('风险等级为LOW，不显示警报');
                    }
                } else {
                    console.log('预测失败，错误信息:', data.error);
                    
                    // 数据不足时显示友好的提示
                    if (data.error && (data.error.includes('数据不足') || data.error.includes('数据点不足'))) {
                        console.log('数据不足，显示友好提示');
                        const predictionCard = document.getElementById('prediction-card');
                        if (predictionCard) {
                            const confidenceEl = document.getElementById('prediction-confidence');
                            if (confidenceEl) {
                                confidenceEl.innerHTML = '<span class="text-muted">数据不足，无法预测</span>';
                            }
                        }
                    } else {
                        // 其他错误，显示通用错误信息
                        console.log('显示通用错误信息');
                        const confidenceEl = document.getElementById('prediction-confidence');
                        if (confidenceEl) {
                            confidenceEl.innerHTML = '<span class="text-muted">预测暂时不可用</span>';
                        }
                    }
                }
            })
            .catch(error => {
                console.error('自动预测失败:', error);
                console.error('错误详情:', {
                    message: error.message,
                    stack: error.stack,
                    type: error.type
                });
                
                // 显示网络错误提示
                const confidenceEl = document.getElementById('prediction-confidence');
                if (confidenceEl) {
                    confidenceEl.innerHTML = '<span class="text-muted">网络连接失败</span>';
                }
                
                // 静默失败，不显示错误信息给用户
            });
    }
    
    // 简单的Markdown解析函数
    function parseMarkdown(text) {
        // 转义HTML
        text = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        
        // 表格处理（需要在其他处理之前）
        text = parseMarkdownTables(text);
        
        // 标题
        text = text.replace(/^###### (.*$)/gm, '<h6>$1</h6>');
        text = text.replace(/^##### (.*$)/gm, '<h5>$1</h5>');
        text = text.replace(/^#### (.*$)/gm, '<h4>$1</h4>');
        text = text.replace(/^### (.*$)/gm, '<h3>$1</h3>');
        text = text.replace(/^## (.*$)/gm, '<h2>$1</h2>');
        text = text.replace(/^# (.*$)/gm, '<h1>$1</h1>');
        
        // 无序列表
        text = text.replace(/^\* (.*$)/gm, '<li>$1</li>');
        text = text.replace(/^- (.*$)/gm, '<li>$1</li>');
        text = text.replace(/^\+ (.*$)/gm, '<li>$1</li>');
        
        // 有序列表
        text = text.replace(/^\d+\. (.*$)/gm, '<li>$1</li>');
        
        // 包装列表项
        text = text.replace(/(<li>.*<\/li>)/s, '<ul>$1</ul>');
        
        // 代码块
        text = text.replace(/```([\s\S]*?)```/g, '<pre><code>$1</code></pre>');
        
        // 行内代码
        text = text.replace(/`([^`]+)`/g, '<code>$1</code>');
        
        // 链接
        text = text.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank">$1</a>');
        
        // 图片
        text = text.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, '<img src="$2" alt="$1" style="max-width: 100%; height: auto;">');
        
        // 粗体
        text = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
        text = text.replace(/__(.*?)__/g, '<strong>$1</strong>');
        
        // 斜体
        text = text.replace(/\*(.*?)\*/g, '<em>$1</em>');
        text = text.replace(/_(.*?)_/g, '<em>$1</em>');
        
        // 换行
        text = text.replace(/\n/g, '<br>');
        
        return text;
    }
    
    // Markdown表格解析函数
    function parseMarkdownTables(text) {
        // 匹配表格格式
        const tableRegex = /(\|.*\|)\n(\|[\s\-\|]+\|)\n((\|.*\|\n?)+)/g;
        
        return text.replace(tableRegex, function(match, headerRow, separatorRow, bodyRows) {
            // 处理表头
            const headers = headerRow.split('|').filter(cell => cell.trim() !== '').map(cell => cell.trim());
            
            // 处理表体
            const rows = bodyRows.trim().split('\n').map(row => 
                row.split('|').filter(cell => cell.trim() !== '').map(cell => cell.trim())
            );
            
            // 构建HTML表格
            let html = '<table class="table table-striped table-bordered">';
            
            // 表头
            html += '<thead><tr>';
            headers.forEach(header => {
                html += `<th>${parseMarkdown(header)}</th>`;
            });
            html += '</tr></thead>';
            
            // 表体
            html += '<tbody>';
            rows.forEach(row => {
                html += '<tr>';
                row.forEach(cell => {
                    html += `<td>${parseMarkdown(cell)}</td>`;
                });
                html += '</tr>';
            });
            html += '</tbody>';
            
            html += '</table>';
            return html;
        });
    }

    // 页面加载完成后自动执行预测
    document.addEventListener('DOMContentLoaded', function() {
        // 延迟1秒执行预测，确保页面完全加载
        setTimeout(loadAutomaticPrediction, 1000);
    });
</script>
{% endblock %}
